

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ballet.validation.entropy &mdash; ballet 0.7.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> ballet
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../readme.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../readme.html#next-steps">Next steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#stable-release">Stable release</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#from-source">From source</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer_guide.html">Maintainer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../maintainer_guide.html#creating-a-ballet-project">Creating a Ballet project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#project-instantiation">Project instantiation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#project-installation">Project installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#collaboration-via-git-and-github">Collaboration via git and GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#enabling-continuous-integration">Enabling continuous integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#installing-bots">Installing bots</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maintainer_guide.html#developing-new-features">Developing new features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#validating-features">Validating features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../maintainer_guide.html#pruning-features">Pruning features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../maintainer_guide.html#applying-the-feature-engineering-pipeline">Applying the feature engineering pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../maintainer_guide.html#updating-the-framework">Updating the framework</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributor_guide.html">Contributor Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributor_guide.html#cloud-feature-development-workflow">Cloud Feature Development Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributor_guide.html#local-feature-development-workflow">Local Feature Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributor_guide.html#setup-your-development-environment">Setup your development environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributor_guide.html#develop-a-new-feature">Develop a new feature</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributor_guide.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../feature_engineering_guide.html">Feature Engineering Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../feature_engineering_guide.html#logical-features">Logical Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../feature_engineering_guide.html#writing-features">Writing features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#a-first-example">A first example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#why">Why?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#input-types-and-conversions">Input types and conversions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#transformers">Transformers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#feature-engineering-pipelines">Feature engineering pipelines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../feature_engineering_guide.html#feature-engineering-primitives">Feature engineering primitives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#preprocessing">Preprocessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#operating-on-groups">Operating on groups</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#addressing-missing-values">Addressing missing values</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#operating-on-time-series-data">Operating on time series data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#other-primitives">Other primitives</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../feature_engineering_guide.html#rolling-your-own-transformers">Rolling your own transformers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../feature_engineering_guide.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../feature_engineering_guide.html#further-reading">Further reading</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/ballet.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/ballet.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.eng.html">ballet.eng package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/ballet.eng.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.util.html">ballet.util package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/ballet.util.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.validation.html">ballet.validation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/ballet.validation.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/ballet.validation.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/ballet.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.cli.html">ballet.cli module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.client.html">ballet.client module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.compat.html">ballet.compat module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.contrib.html">ballet.contrib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.exc.html">ballet.exc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.feature.html">ballet.feature module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.pipeline.html">ballet.pipeline module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.project.html">ballet.project module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.templating.html">ballet.templating module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.transformer.html">ballet.transformer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/ballet.update.html">ballet.update module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cli_reference.html">CLI Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../cli_reference.html#ballet-quickstart">quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../cli_reference.html#ballet-start-new-feature">start-new-feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../cli_reference.html#ballet-update-project-template">update-project-template</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../cli_reference.html#ballet-validate">validate</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Development Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#types-of-contributions">Types of Contributions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#report-bugs">Report Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#fix-bugs">Fix Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#implement-features">Implement Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#write-documentation">Write Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#submit-feedback">Submit Feedback</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#get-started">Get Started!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#pull-request-guidelines">Pull Request Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#tips">Tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#deploying">Deploying</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Credits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../authors.html#development-lead">Development Lead</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../authors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../history.html">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id1">0.7.1 (2020-07-20)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id2">0.7 (2020-07-17)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id3">0.6 (2019-11-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id4">0.5 (2018-10-14)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id5">0.4 (2018-09-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id6">0.3 (2018-04-28)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id7">0.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../history.html#id8">0.1</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ballet</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ballet.validation.entropy</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ballet.validation.entropy</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">digamma</span><span class="p">,</span> <span class="n">gamma</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_consistent_length</span>

<span class="kn">from</span> <span class="nn">ballet.util</span> <span class="kn">import</span> <span class="n">asarray2d</span><span class="p">,</span> <span class="n">nonnegative</span>
<span class="kn">from</span> <span class="nn">ballet.util.log</span> <span class="kn">import</span> <span class="n">logger</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;estimate_conditional_information&#39;</span><span class="p">,</span>
    <span class="s1">&#39;estimate_entropy&#39;</span><span class="p">,</span>
    <span class="s1">&#39;estimate_mutual_information&#39;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">N_NEIGHBORS</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># hyperparameter k from KSG estimator</span>
<span class="n">NEIGHBORS_ALGORITHM</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
<span class="n">NEIGHBORS_METRIC</span> <span class="o">=</span> <span class="s1">&#39;chebyshev&#39;</span>
<span class="n">DISC_COL_UNIQUE_VAL_THRESH</span> <span class="o">=</span> <span class="mf">0.05</span>


<span class="c1"># Helpers</span>

<span class="k">def</span> <span class="nf">_make_neighbors</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="n">NEIGHBORS_ALGORITHM</span><span class="p">,</span>
                            <span class="n">metric</span><span class="o">=</span><span class="n">NEIGHBORS_METRIC</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_empirical_probability</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute empirical probability of events in x</span>

<span class="sd">    Args:</span>
<span class="sd">        x: array-like</span>

<span class="sd">    Returns:</span>
<span class="sd">        pk: array-like of shape (K,) where where p[k] is the probability of</span>
<span class="sd">            event k</span>
<span class="sd">        events: array-like of shape (K, m) where each event is a vector of</span>
<span class="sd">            length m and there are K unique events</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">events</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pk</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">pk</span><span class="p">,</span> <span class="n">events</span>


<span class="k">def</span> <span class="nf">_compute_volume_unit_ball</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">NEIGHBORS_METRIC</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute volume of a d-dimensional unit ball in R^d with given metric&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;metric </span><span class="si">{metric}</span><span class="s1"> not supported&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_column_disc</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># Heuristics to decide if column is discrete</span>

    <span class="c1"># Integer columns are discrete</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Real-valued columns that are close to integer values are discrete</span>
    <span class="n">rounding_error</span> <span class="o">=</span> <span class="n">col</span> <span class="o">-</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">rounding_error</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">size</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Columns with a small fraction of distinct values are discrete</span>
    <span class="n">uniques</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uniques</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">col</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DISC_COL_UNIQUE_VAL_THRESH</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_is_column_cont</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">_is_column_disc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_disc_columns</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">_is_column_disc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="c1"># Computing epsilon</span>

<span class="k">def</span> <span class="nf">_compute_epsilon</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate epsilon from KSG Estimator</span>

<span class="sd">    Represents twice the distance of each element to its k-th nearest neighbor.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array with shape (n_samples, n_features)</span>

<span class="sd">    Returns:</span>
<span class="sd">        An array with shape (n_samples, 1) representing</span>
<span class="sd">            epsilon as described above.</span>

<span class="sd">    References:</span>

<span class="sd">    .. [1] A. Kraskov, H. Stogbauer and P. Grassberger, &quot;Estimating mutual</span>
<span class="sd">           information&quot;. Phys. Rev. E 69, 2004.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">N_NEIGHBORS</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">disc_mask</span> <span class="o">=</span> <span class="n">_get_disc_columns</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">disc_mask</span><span class="p">):</span>
        <span class="c1"># if no continuous columns, there&#39;s no point getting epsilon</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="o">~</span><span class="n">disc_mask</span><span class="p">]</span>

    <span class="n">nn</span> <span class="o">=</span> <span class="n">_make_neighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># if the kth neighbor is at distance 0, then we are in trouble</span>
    <span class="c1"># but we can try the trick of increasing k if we don&#39;t use the old</span>
    <span class="c1"># value of k sometime later</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># distances to k-nearest neighbor</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">asarray2d</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">distances</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_n_points_within_radius_i</span><span class="p">(</span>
    <span class="n">nn</span><span class="p">:</span> <span class="n">NearestNeighbors</span><span class="p">,</span>
    <span class="n">x_i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">radius_i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">radius_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="c1"># adjustment as radius_neighbors would find exact matches</span>
    <span class="n">radius_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="n">radius_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">x_i</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius_i</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>


<span class="k">def</span> <span class="nf">_ithrow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="c1"># seem to need to index as x[i:i+1, :] to get a (1,m) row array.</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>


<span class="k">def</span> <span class="nf">_compute_n_points_within_radius</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the number of points strictly within some radius</span>

<span class="sd">    Note that points lying exactly on the radius are not counted.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: data of shape (n_instances, n_features)</span>
<span class="sd">        radius: radius from each point of shape (n_instances, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_consistent_length</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">nn</span> <span class="o">=</span> <span class="n">_make_neighbors</span><span class="p">()</span>
    <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># this will be slow</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">_compute_n_points_within_radius_i</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">_ithrow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">radius</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="k">return</span> <span class="n">nx</span>


<span class="c1"># Entropy estimation</span>

<span class="k">def</span> <span class="nf">_estimate_disc_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the Shannon entropy of a discrete dataset.</span>

<span class="sd">    The Shannon entropy of a discrete random variable :math:`Z` with support</span>
<span class="sd">    :math:`\mathbb{Z}` and density :math:`P_Z` is given as</span>

<span class="sd">    .. math::</span>
<span class="sd">        H(Z) = -\sum_{z \in \mathbb{Z}} P_Z(z) \log(P_Z(z))</span>

<span class="sd">    Here, since we do not know :math:`P_Z`, we estimate :math:`\hat{P}_Z`, the</span>
<span class="sd">    empirical probability, calculated as the frequency in the dataset x.</span>

<span class="sd">    If x&#39;s columns logically represent continuous features, it is better to use</span>
<span class="sd">    the `_estimate_cont_entropy` function. If you are unsure of which to use,</span>
<span class="sd">    `estimate_entropy` can take datasets of mixed discrete and continuous</span>
<span class="sd">    functions.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Dataset with shape (n_samples, n_features) or</span>
<span class="sd">            (n_samples, )</span>

<span class="sd">    Returns:</span>
<span class="sd">        the dataset entropy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">pk</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_compute_empirical_probability</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_estimate_cont_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Estimate the differential entropy of a continuous dataset.</span>

<span class="sd">    Based off the KSG Estimator [1] for a dataset&#39;s differential entropy.</span>
<span class="sd">    If epsilon is provided, this is a partial estimation of the KSG entropy</span>
<span class="sd">    estimator. The bias is cancelled out when computing mutual information.</span>

<span class="sd">    The function relies on nonparametric methods based on entropy estimation</span>
<span class="sd">    from k-nearest neighbors distances as proposed in [1] and augmented in [2]</span>
<span class="sd">    for mutual information estimation.</span>

<span class="sd">    If X&#39;s columns logically represent discrete features, it is better to use</span>
<span class="sd">    the _estimate_disc_entropy function. If you are unsure of which to use,</span>
<span class="sd">    _estimate_entropy can take datasets of mixed discrete and continuous</span>
<span class="sd">    functions.</span>

<span class="sd">    Observe that differential entropy is *not* the &quot;extension&quot; of the</span>
<span class="sd">    Shannon entropy and thus it does not exhibit some properties like</span>
<span class="sd">    non-negativity (i.e. values below zero are possible).</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Dataset with shape (n_samples, n_features) or</span>
<span class="sd">            (n_samples, )</span>
<span class="sd">        epsilon: An array with shape (n_samples, 1) that is</span>
<span class="sd">            the epsilon used in KSG Estimator. Represents the Chebyshev</span>
<span class="sd">            distance from an element to its k-th nearest neighbor in the full</span>
<span class="sd">            dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        differential entropy of the dataset</span>

<span class="sd">    References:</span>

<span class="sd">    .. [1] A. Kraskov, H. Stogbauer and P. Grassberger, &quot;Estimating mutual</span>
<span class="sd">           information&quot;. Phys. Rev. E 69, 2004.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">_compute_n_points_within_radius</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">c_d</span> <span class="o">=</span> <span class="n">_compute_volume_unit_ball</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">digamma</span><span class="p">(</span><span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">digamma</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_d</span><span class="p">)</span> \
        <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">epsilon</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_estimate_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Estimate dataset entropy.&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># not enough data</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">disc_mask</span> <span class="o">=</span> <span class="n">_get_disc_columns</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">cont_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">disc_mask</span>

    <span class="c1"># if all columns are disc, use discrete-specific estimator</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">disc_mask</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_estimate_disc_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># if all columns are cont, use continuous-specific estimator</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">cont_mask</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_estimate_cont_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="c1"># Separate the dataset into discrete and continuous datasets d and c</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">disc_mask</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">cont_mask</span><span class="p">])</span>

    <span class="c1"># H(c|d)</span>
    <span class="n">H_c_d</span> <span class="o">=</span> <span class="n">_estimate_conditional_entropy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="c1"># H(d)</span>
    <span class="n">H_d</span> <span class="o">=</span> <span class="n">_estimate_disc_entropy</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">H_d</span> <span class="o">+</span> <span class="n">H_c_d</span>


<span class="k">def</span> <span class="nf">_estimate_conditional_entropy</span><span class="p">(</span>
    <span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Estimate H(c|d) where c is continuous and d is discrete&quot;&quot;&quot;</span>
    <span class="c1"># H(c|d) = \sum_{i} p(d_i) H(c|d=d_i)</span>
    <span class="c1"># where we i ranges over unique values of d and c_d_i is the</span>
    <span class="c1"># rows of c where d == d_i.</span>
    <span class="n">pk</span><span class="p">,</span> <span class="n">events</span> <span class="o">=</span> <span class="n">_compute_empirical_probability</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">H_c_d</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p_i</span><span class="p">,</span> <span class="n">d_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="n">events</span><span class="p">)):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">d_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">c_di</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># TODO add logging here about small sample size</span>
        <span class="n">epsilon_di</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">H_c_di</span> <span class="o">=</span> <span class="n">_estimate_cont_entropy</span><span class="p">(</span><span class="n">c_di</span><span class="p">,</span> <span class="n">epsilon_di</span><span class="p">)</span>
        <span class="n">H_c_d</span> <span class="o">+=</span> <span class="n">p_i</span> <span class="o">*</span> <span class="n">H_c_di</span>
    <span class="k">return</span> <span class="n">H_c_d</span>


<span class="c1"># Public API</span>

<div class="viewcode-block" id="estimate_entropy"><a class="viewcode-back" href="../../../api/ballet.validation.entropy.html#ballet.validation.entropy.estimate_entropy">[docs]</a><span class="nd">@nonnegative</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">estimate_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate dataset entropy.</span>

<span class="sd">    This function can take datasets of mixed discrete and continuous features,</span>
<span class="sd">    and uses a set of heuristics to determine which functions to apply to</span>
<span class="sd">    each. Discrete (Shannon) entropy is estimated via the empirical</span>
<span class="sd">    probability mass function. Continuous (differential) entropy is</span>
<span class="sd">    estimated via the KSG estimator [1].</span>

<span class="sd">    Let x be made of continuous features c and discrete features d.</span>
<span class="sd">    To deal with both continuous and discrete features, We use the</span>
<span class="sd">    following reworking of entropy:</span>

<span class="sd">    .. math::</span>
<span class="sd">       :nowrap:</span>

<span class="sd">       \begin{align}</span>
<span class="sd">       H(x) &amp;= H(c,d) \\</span>
<span class="sd">            &amp;= H(d) + H(c | d) \\</span>
<span class="sd">            &amp;= \sum_{x \in d} p(x) H(c(x)) + H(d),</span>
<span class="sd">       \end{align}</span>

<span class="sd">    where :math:`c(x)` is a dataset that represents the rows of the continuous</span>
<span class="sd">    dataset in the same row as a discrete column with value x in the original</span>
<span class="sd">    dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Dataset with shape (n_samples, n_features) or</span>
<span class="sd">            (n_samples, )</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dataset entropy of X.</span>

<span class="sd">    References:</span>

<span class="sd">    .. [1] A. Kraskov, H. Stogbauer and P. Grassberger, &quot;Estimating mutual</span>
<span class="sd">           information&quot;. Phys. Rev. E 69, 2004.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_compute_epsilon</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span></div>


<div class="viewcode-block" id="estimate_conditional_information"><a class="viewcode-back" href="../../../api/ballet.validation.entropy.html#ballet.validation.entropy.estimate_conditional_information">[docs]</a><span class="nd">@nonnegative</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">estimate_conditional_information</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the conditional mutual information of x and y given z</span>

<span class="sd">    Conditional mutual information is the mutual information of two datasets,</span>
<span class="sd">    given a third:</span>

<span class="sd">    .. math::</span>
<span class="sd">       I(x;y|z) = H(x,z) + H(y,z) - H(x,y,z) - H(z)</span>

<span class="sd">    Where :math:`H(X)` is the Shannon entropy of dataset :math:`X`. For</span>
<span class="sd">    continuous datasets, adapts the KSG Estimator [1] for mutual</span>
<span class="sd">    information.</span>

<span class="sd">    Eq 8 from [1] holds because the epsilon terms cancel out.</span>
<span class="sd">    Let :math:`d_x`, represent the dimensionality of the continuous portion of</span>
<span class="sd">    x. Then, we see that:</span>

<span class="sd">    .. math::</span>
<span class="sd">       :nowrap:</span>

<span class="sd">       \begin{align}</span>
<span class="sd">       d_{xz} + d_{yz} - d_{xyz} - d_z</span>
<span class="sd">           &amp;= (d_x + d_z) + (d_y + d_z) - (d_x + d_y + d_z) - d_z \\</span>
<span class="sd">           &amp;= 0</span>
<span class="sd">       \end{align}</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array with shape (n_samples, n_features_x)</span>
<span class="sd">        y: An array with shape (n_samples, n_features_y)</span>
<span class="sd">        z: An array with shape (n_samples, n_features_z).</span>
<span class="sd">            This is the dataset being conditioned on.</span>

<span class="sd">    Returns:</span>
<span class="sd">        conditional mutual information of x and y given z.</span>

<span class="sd">    References:</span>

<span class="sd">    .. [1] A. Kraskov, H. Stogbauer and P. Grassberger, &quot;Estimating mutual</span>
<span class="sd">           information&quot;. Phys. Rev. E 69, 2004.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_compute_epsilon</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

    <span class="n">H_xz</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">xz</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">H_yz</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">yz</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">H_xyz</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">H_z</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;H(X,Z): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">H_xz</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;H(Y,Z): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">H_yz</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;H(X,Y,Z): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">H_xyz</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;H(Z): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">H_z</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">H_xz</span> <span class="o">+</span> <span class="n">H_yz</span> <span class="o">-</span> <span class="n">H_xyz</span> <span class="o">-</span> <span class="n">H_z</span></div>


<div class="viewcode-block" id="estimate_mutual_information"><a class="viewcode-back" href="../../../api/ballet.validation.entropy.html#ballet.validation.entropy.estimate_mutual_information">[docs]</a><span class="nd">@nonnegative</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">estimate_mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Estimate the mutual information of two datasets.</span>

<span class="sd">    Mutual information is a measure of dependence between</span>
<span class="sd">    two datasets and is calculated as:</span>

<span class="sd">    .. math::</span>
<span class="sd">       I(x;y) = H(x) + H(y) - H(x,y)</span>

<span class="sd">    Where H(x) is the Shannon entropy of x. For continuous datasets,</span>
<span class="sd">    adapts the KSG Estimator [1] for mutual information.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array with shape (n_samples, n_features_x)</span>
<span class="sd">        y: An array with shape (n_samples, n_features_y)</span>

<span class="sd">    Returns:</span>
<span class="sd">        mutual information of x and y</span>

<span class="sd">    References:</span>

<span class="sd">    .. [1] A. Kraskov, H. Stogbauer and P. Grassberger, &quot;Estimating mutual</span>
<span class="sd">      information&quot;. Phys. Rev. E 69, 2004.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_compute_epsilon</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
    <span class="n">H_x</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">H_y</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">H_xy</span> <span class="o">=</span> <span class="n">_estimate_entropy</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H_x</span> <span class="o">+</span> <span class="n">H_y</span> <span class="o">-</span> <span class="n">H_xy</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018, Micah Smith

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>