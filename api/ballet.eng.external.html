

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ballet.eng.external module &mdash; ballet 0.7.10 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ballet.eng.feature_engine module" href="ballet.eng.feature_engine.html" />
    <link rel="prev" title="ballet.eng.category_encoders module" href="ballet.eng.category_encoders.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> ballet
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../readme.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../readme.html#next-steps">Next steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#stable-release">Stable release</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#from-source">From source</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../maintainer_guide.html">Maintainer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#creating-a-ballet-project">Creating a Ballet project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#project-instantiation">Project instantiation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#project-installation">Project installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#collaboration-via-git-and-github">Collaboration via git and GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#enabling-continuous-integration">Enabling continuous integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#installing-bots">Installing bots</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#developing-new-features">Developing new features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#validating-features">Validating features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#pruning-features">Pruning features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#applying-the-feature-engineering-pipeline">Applying the feature engineering pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#updating-the-framework">Updating the framework</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributor_guide.html">Contributor Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#cloud-feature-development-workflow">Cloud Feature Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#launch-binder">Launch binder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#work-in-a-notebook">Work in a notebook</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#authenticate-with-github">Authenticate with GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#develop-a-new-feature">Develop a new feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#test-your-feature">Test your feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#submit-your-feature">Submit your feature</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#local-feature-development-workflow">Local Feature Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#setup-your-development-environment">Setup your development environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#fork-the-project">Fork the project</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#clone-your-fork">Clone your fork</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#create-a-virtualenv">Create a virtualenv</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#contributor-guide-develop-a-new-feature-local">Develop a new feature</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#update-and-install-the-project">Update and install the project</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#start-working-on-a-new-feature">Start working on a new feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#write-your-feature">Write your feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#contributor-guide-test-your-feature-local">Test your feature</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#submit-the-feature">Submit the feature</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#option-1-git-workflow">Option 1: Git workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#option-2-in-lab-workflow">Option 2: In-Lab Workflow</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#understanding-validation-results">Understanding Validation Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../feature_engineering_guide.html">Feature Engineering Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#logical-features">Logical Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#why">Why?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#writing-features">Writing features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#a-first-example">A first example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#a-second-example">A second example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#a-third-example">A third example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#input-types-and-conversions">Input types and conversions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#transformers">Transformers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#feature-engineering-pipelines">Feature engineering pipelines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#feature-engineering-primitives">Feature engineering primitives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#operating-on-groups">Operating on groups</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#addressing-missing-values">Addressing missing values</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#operating-on-time-series-data">Operating on time series data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#other-primitives">Other primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#external-libraries">External libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#pandas-ballet-examples">Pandas ⇔ Ballet Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#rolling-your-own-transformers">Rolling your own transformers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#further-reading">Further reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#how-can-i-check-the-performance-of-a-feature">How can I check the performance of a feature?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#there-was-an-error-submitting-my-feature-using-the-ballet-submit-button-in-jupyter-lab">There was an error submitting my feature using the Ballet Submit button in Jupyter Lab.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#my-feature-has-a-valid-api-locally-why-was-it-rejected">My feature has a valid API locally, why was it rejected?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#why-did-my-feature-fail-the-feature-acceptance-validation">Why did my feature fail the feature acceptance validation?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#my-feature-relies-on-a-new-library-how-can-i-add-it-to-the-project">My feature relies on a new library, how can I add it to the project?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#how-can-i-learn-to-write-better-features">How can I learn to write better features?</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="ballet.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="ballet.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="ballet.eng.html">ballet.eng package</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="ballet.eng.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ballet.util.html">ballet.util package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ballet.util.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ballet.validation.html">ballet.validation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ballet.validation.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="ballet.validation.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ballet.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ballet.cli.html">ballet.cli module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.client.html">ballet.client module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.compat.html">ballet.compat module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.contrib.html">ballet.contrib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.exc.html">ballet.exc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.feature.html">ballet.feature module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.pipeline.html">ballet.pipeline module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.project.html">ballet.project module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.templating.html">ballet.templating module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.transformer.html">ballet.transformer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.update.html">ballet.update module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cli_reference.html">CLI Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-quickstart">quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-start-new-feature">start-new-feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-update-project-template">update-project-template</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-validate">validate</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Development Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#types-of-contributions">Types of Contributions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#report-bugs">Report Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#fix-bugs">Fix Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#implement-features">Implement Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#write-documentation">Write Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#submit-feedback">Submit Feedback</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#get-started">Get Started!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#pull-request-guidelines">Pull Request Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#tips">Tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#deploying">Deploying</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Credits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../authors.html#development-lead">Development Lead</a></li>
<li class="toctree-l2"><a class="reference internal" href="../authors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id1">0.7.10 (2020-09-08)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id2">0.7.9 (2020-08-15)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id3">0.7.8 (2020-08-13)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id4">0.7.7 (2020-08-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id5">0.7.6 (2020-08-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id6">0.7.5 (2020-08-03)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id7">0.7.4 (2020-07-22)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id8">0.7.3 (2020-07-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id9">0.7.2 (2020-07-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id10">0.7.1 (2020-07-20)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id11">0.7 (2020-07-17)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id12">0.6 (2019-11-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id13">0.5 (2018-10-14)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id14">0.4 (2018-09-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id15">0.3 (2018-04-28)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id16">0.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id17">0.1</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ballet</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="ballet.html">ballet package</a> &raquo;</li>
        
          <li><a href="ballet.eng.html">ballet.eng package</a> &raquo;</li>
        
      <li>ballet.eng.external module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/HDI-Project/ballet/blob/master/docs/api/ballet.eng.external.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-ballet.eng.external">
<span id="ballet-eng-external-module"></span><h1>ballet.eng.external module<a class="headerlink" href="#module-ballet.eng.external" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="ballet.eng.external.AddMissingIndicator">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">AddMissingIndicator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">how</span><span class="o">=</span><span class="default_value">'missing_only'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#AddMissingIndicator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AddMissingIndicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>The AddMissingIndicator() adds an additional column or binary variable that
indicates if data is missing.</p>
<p>AddMissingIndicator() will add as many missing indicators as variables
indicated by the user, or variables with missing data in the train set.</p>
<p>The AddMissingIndicator() works for both numerical and categorical variables.
The user can pass a list with the variables for which the missing indicators
should be added as a list. Alternatively, the imputer will select and add missing
indicators to all variables in the training set that show missing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>how</strong> (<em>string</em><em>, </em><em>defatul='missing_only'</em>) – <p>Indicates if missing indicators should be added to variables with missing
data or to all variables.</p>
<p>missing_only: indicators will be created only for those variables that showed
missing data during fit.</p>
<p>all: indicators will be created for all variables</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables to be imputed. If None, the imputer will find and
select all variables with missing data.
Note: the transformer will first select all variables or all user entered variables
and if how=missing_only, it will re-select from the original group only those
that show missing data in during fit.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.AddMissingIndicator.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#AddMissingIndicator.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AddMissingIndicator.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the variables for which the missing indicators will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.AddMissingIndicator.variables_">
<code class="sig-name descname">variables_</code><a class="headerlink" href="#ballet.eng.external.AddMissingIndicator.variables_" title="Permalink to this definition">¶</a></dt>
<dd><p>the lit of variables for which the missing indicator will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.AddMissingIndicator.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#AddMissingIndicator.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AddMissingIndicator.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the binary missing indicators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The dataframe to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe containing the additional binary variables.
Binary variables are named with the original variable name plus
‘_na’.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.ArbitraryNumberImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">ArbitraryNumberImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arbitrary_number</span><span class="o">=</span><span class="default_value">999</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">imputer_dict</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#ArbitraryNumberImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ArbitraryNumberImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseImputer</span></code></p>
<p>The ArbitraryNumberImputer() replaces missing data in each variable
by an arbitrary value determined by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arbitrary_number</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>default=999</em>) – the number to be used to replace missing data.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables to be imputed. If None, the imputer will find and
select all numerical type variables. Attribute is used only if <cite>imputer_dict</cite>
attribute is None.</p></li>
<li><p><strong>imputer_dict</strong> (<em>dict</em><em>, </em><em>default=None</em>) – The dictionary of variables and their arbitrary numbers. If imputer_dict is not None,
it has to be dictionary with all values of integer or float type.
If None, <cite>variables</cite> attribute is used for imputation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.ArbitraryNumberImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#ArbitraryNumberImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ArbitraryNumberImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the variables are numerical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
User can pass the entire dataframe, not just the variables to impute.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.ArbitraryNumberImputer.imputer_dict_">
<code class="sig-name descname">imputer_dict_</code><a class="headerlink" href="#ballet.eng.external.ArbitraryNumberImputer.imputer_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the values that will be used to replace each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.ArbitraryNumberImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#ArbitraryNumberImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ArbitraryNumberImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.ArbitraryOutlierCapper">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">ArbitraryOutlierCapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_capping_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_capping_dict</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">missing_values</span><span class="o">=</span><span class="default_value">'raise'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#ArbitraryOutlierCapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ArbitraryOutlierCapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>The ArbitraryOutlierCapper() caps the maximum or minimum values of a variable
by an arbitrary value indicated by the user.</p>
<p>The user must provide the maximum or minimum values that will be used
to cap each variable in a dictionary {feature:capping value}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>capping_max</strong> (<em>dictionary</em><em>, </em><em>default=None</em>) – user specified capping values on right tail of the distribution (maximum
values).</p></li>
<li><p><strong>capping_min</strong> (<em>dictionary</em><em>, </em><em>default=None</em>) – user specified capping values on left tail of the distribution (minimum
values).</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='raise'</em>) – Indicates if missing values should be ignored or raised. If
missing_values=’raise’ the transformer will return an error if the
training or other datasets contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.ArbitraryOutlierCapper.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#ArbitraryOutlierCapper.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ArbitraryOutlierCapper.fit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.ArbitraryOutlierCapper.right_tail_caps_">
<code class="sig-name descname">right_tail_caps_</code><a class="headerlink" href="#ballet.eng.external.ArbitraryOutlierCapper.right_tail_caps_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the maximum values at which variables
will be capped.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.ArbitraryOutlierCapper.left_tail_caps_">
<code class="sig-name descname">left_tail_caps_</code><a class="headerlink" href="#ballet.eng.external.ArbitraryOutlierCapper.left_tail_caps_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the minimum values at which variables
will be capped.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.ArbitraryOutlierCapper.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#ArbitraryOutlierCapper.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ArbitraryOutlierCapper.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Caps the variable values, that is, censors outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe with the capped variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.AutoregressiveTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">AutoregressiveTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_lags</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pred_stride</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#AutoregressiveTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AutoregressiveTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.AutoregressiveTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#AutoregressiveTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AutoregressiveTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.AutoregressiveTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#AutoregressiveTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AutoregressiveTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.AutoregressiveTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#AutoregressiveTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.AutoregressiveTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.BackwardDifferenceEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">BackwardDifferenceEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/backward_difference.html#BackwardDifferenceEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BackwardDifferenceEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Backward difference contrast coding for encoding categorical variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has unknown categories.  This can cause
unexpected changes in dimension in some cases.</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has nan values.  This can cause
unexpected changes in dimension in some cases.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">BackwardDifferenceEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 21 columns):</span>
<span class="go">intercept    506 non-null int64</span>
<span class="go">CRIM         506 non-null float64</span>
<span class="go">ZN           506 non-null float64</span>
<span class="go">INDUS        506 non-null float64</span>
<span class="go">CHAS_0       506 non-null float64</span>
<span class="go">NOX          506 non-null float64</span>
<span class="go">RM           506 non-null float64</span>
<span class="go">AGE          506 non-null float64</span>
<span class="go">DIS          506 non-null float64</span>
<span class="go">RAD_0        506 non-null float64</span>
<span class="go">RAD_1        506 non-null float64</span>
<span class="go">RAD_2        506 non-null float64</span>
<span class="go">RAD_3        506 non-null float64</span>
<span class="go">RAD_4        506 non-null float64</span>
<span class="go">RAD_5        506 non-null float64</span>
<span class="go">RAD_6        506 non-null float64</span>
<span class="go">RAD_7        506 non-null float64</span>
<span class="go">TAX          506 non-null float64</span>
<span class="go">PTRATIO      506 non-null float64</span>
<span class="go">B            506 non-null float64</span>
<span class="go">LSTAT        506 non-null float64</span>
<span class="go">dtypes: float64(20), int64(1)</span>
<span class="go">memory usage: 83.1 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p>Contrast Coding Systems for Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/</a></p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">2</span></dt>
<dd><p>Gregory Carey (2003). Coding Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf">http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf</a></p>
<dl class="py method">
<dt id="ballet.eng.external.BackwardDifferenceEncoder.backward_difference_coding">
<em class="property">static </em><code class="sig-name descname">backward_difference_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">mapping</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/backward_difference.html#BackwardDifferenceEncoder.backward_difference_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BackwardDifferenceEncoder.backward_difference_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BackwardDifferenceEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/backward_difference.html#BackwardDifferenceEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BackwardDifferenceEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits an ordinal encoder to produce a consistent mapping across applications and optionally finds
generally invariant columns to drop consistently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BackwardDifferenceEncoder.fit_backward_difference_coding">
<em class="property">static </em><code class="sig-name descname">fit_backward_difference_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">col</span></em>, <em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="n">handle_missing</span></em>, <em class="sig-param"><span class="n">handle_unknown</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/backward_difference.html#BackwardDifferenceEncoder.fit_backward_difference_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BackwardDifferenceEncoder.fit_backward_difference_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BackwardDifferenceEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/backward_difference.html#BackwardDifferenceEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BackwardDifferenceEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BackwardDifferenceEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/backward_difference.html#BackwardDifferenceEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BackwardDifferenceEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.BaseNEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">BaseNEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">base</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Base-N encoder encodes the categories into arrays of their base-N representation.  A base of 1 is equivalent to
one-hot encoding (not really base-1, but useful), a base of 2 is equivalent to binary encoding. N=number of actual
categories is equivalent to vanilla ordinal encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>base</strong> (<em>int</em>) – when the downstream model copes well with nonlinearities (like decision tree), use higher base.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has unknown categories.  This can cause
unexpected changes in dimension in some cases.</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has nan values.  This can cause
unexpected changes in dimension in some cases.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">BaseNEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 18 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS_0     506 non-null int64</span>
<span class="go">CHAS_1     506 non-null int64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD_0      506 non-null int64</span>
<span class="go">RAD_1      506 non-null int64</span>
<span class="go">RAD_2      506 non-null int64</span>
<span class="go">RAD_3      506 non-null int64</span>
<span class="go">RAD_4      506 non-null int64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(11), int64(7)</span>
<span class="go">memory usage: 71.3 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.basen_encode">
<code class="sig-name descname">basen_encode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.basen_encode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.basen_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Basen encoding encodes the integers as basen code with one column per digit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_in</strong> (<em>DataFrame</em>) – </p></li>
<li><p><strong>cols</strong> (<em>list-like</em><em>, </em><em>default None</em>) – Column names in the DataFrame to be encoded</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dummies</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.basen_to_integer">
<code class="sig-name descname">basen_to_integer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">cols</span></em>, <em class="sig-param"><span class="n">base</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.basen_to_integer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.basen_to_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert basen code as integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>DataFrame</em>) – encoded data</p></li>
<li><p><strong>cols</strong> (<em>list-like</em>) – Column names in the DataFrame that be encoded</p></li>
<li><p><strong>base</strong> (<em>int</em>) – The base of transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>numerical</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.calc_required_digits">
<code class="sig-name descname">calc_required_digits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.calc_required_digits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.calc_required_digits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.col_transform">
<code class="sig-name descname">col_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">col</span></em>, <em class="sig-param"><span class="n">digits</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.col_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.col_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>The lambda body to transform the column values</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.fit_base_n_encoding">
<code class="sig-name descname">fit_base_n_encoding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.fit_base_n_encoding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.fit_base_n_encoding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the inverse transformation to encoded data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_in</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, the same size of X_in</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.number_to_base">
<em class="property">static </em><code class="sig-name descname">number_to_base</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">limit</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.number_to_base"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.number_to_base" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BaseNEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/basen.html#BaseNEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BaseNEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.Binarizer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">Binarizer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#Binarizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Binarizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Binarize data (set feature values to 0 or 1) according to a threshold</p>
<p>Values greater than the threshold map to 1, while values less than
or equal to the threshold map to 0. With the default threshold of 0,
only positive values map to 1.</p>
<p>Binarization is a common operation on text count data where the
analyst can decide to only consider the presence or absence of a
feature rather than a quantified number of occurrences for instance.</p>
<p>It can also be used as a pre-processing step for estimators that
consider boolean random variables (e.g. modelled using the Bernoulli
distribution in a Bayesian setting).</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em><em> (</em><em>0.0 by default</em><em>)</em>) – Feature values below or equal to this are replaced by 0, above it by 1.
Threshold may not be less than 0 for operations on sparse matrices.</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – set to False to perform inplace binarization and avoid a copy (if
the input is already a numpy array or a scipy.sparse CSR matrix).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Binarizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">Binarizer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># fit does nothing.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span>
<span class="go">Binarizer()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[1., 0., 1.],</span>
<span class="go">       [1., 0., 0.],</span>
<span class="go">       [0., 1., 0.]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>If the input is a sparse matrix, only the non-zero values are subject
to update by the Binarizer class.</p>
<p>This estimator is stateless (besides constructor parameters), the
fit method does nothing but is useful when used in a pipeline.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">binarize</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt id="ballet.eng.external.Binarizer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#Binarizer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Binarizer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing and return the estimator unchanged</p>
<p>This method is just there to implement the usual API and hence
work in pipelines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.Binarizer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#Binarizer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Binarizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Binarize each element of X</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to binarize, element by element.
scipy.sparse matrices should be in CSR format to avoid an
un-necessary copy.</p></li>
<li><p><strong>copy</strong> (<em>bool</em>) – Copy the input X or not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.BinaryEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">BinaryEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/binary.html#BinaryEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BinaryEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Binary encoding for categorical variables, similar to onehot, but stores categories as binary bitstrings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has unknown categories.  This can cause
unexpected changes in dimension in some cases.</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has nan values.  This can cause
unexpected changes in dimension in some cases.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">BinaryEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 18 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS_0     506 non-null int64</span>
<span class="go">CHAS_1     506 non-null int64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD_0      506 non-null int64</span>
<span class="go">RAD_1      506 non-null int64</span>
<span class="go">RAD_2      506 non-null int64</span>
<span class="go">RAD_3      506 non-null int64</span>
<span class="go">RAD_4      506 non-null int64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(11), int64(7)</span>
<span class="go">memory usage: 71.3 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.BinaryEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/binary.html#BinaryEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BinaryEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BinaryEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/binary.html#BinaryEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BinaryEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BinaryEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/binary.html#BinaryEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BinaryEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the inverse transformation to encoded data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_in</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, the same size of X_in</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BinaryEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/binary.html#BinaryEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BinaryEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.BoxCoxTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">BoxCoxTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#BoxCoxTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BoxCoxTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The BoxCoxTransformer() applies the BoxCox transformation to numerical
variables.</p>
<p>The BoxCox transformation implemented by this transformer is that of
SciPy.stats:
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html</a></p>
<p>The BoxCoxTransformer() works only with numerical positive variables (&gt;=0,
the transformer also works for zero values).</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.BoxCoxTransformer.lamda_dict_">
<code class="sig-name descname">lamda_dict_</code><a class="headerlink" href="#ballet.eng.external.BoxCoxTransformer.lamda_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {variable: best exponent for the BoxCox
transfomration} pairs. These are determined automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BoxCoxTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#BoxCoxTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BoxCoxTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the optimal lambda for the BoxCox transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to transform.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.BoxCoxTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#BoxCoxTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.BoxCoxTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the BoxCox transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe with the transformed variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.CatBoostEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">CatBoostEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/cat_boost.html#CatBoostEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CatBoostEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>CatBoost coding for categorical features.</p>
<p>This is very similar to leave-one-out encoding, but calculates the
values “on-the-fly”. Consequently, the values naturally vary
during the training phase and it is not necessary to add random noise.</p>
<p>Beware, the training data have to be randomly permutated. E.g.:</p>
<blockquote>
<div><p># Random permutation
perm = np.random.permutation(len(X))
X = X.iloc[perm].reset_index(drop=True)
y = y.iloc[perm].reset_index(drop=True)</p>
</div></blockquote>
<p>This is necessary because some data sets are sorted based on the target
value and this coder encodes the features on-the-fly in a single pass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’  and ‘value’, defaults to ‘value’, which returns the target mean.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’ and ‘value’, defaults to ‘value’, which returns the target mean.</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – adds normal (Gaussian) distribution noise into training data in order to decrease overfitting (testing data are untouched).
sigma gives the standard deviation (spread or “width”) of the normal distribution.</p></li>
<li><p><strong>a</strong> (<em>float</em>) – additive smoothing (it is the same variable as “m” in m-probability estimate). By default set to 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">CatBoostEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">1</span></dt>
<dd><p>Transforming categorical features to numerical features, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://tech.yandex.com/catboost/doc/dg/concepts/algorithm-main-stages_cat-to-numberic-docpage/">https://tech.yandex.com/catboost/doc/dg/concepts/algorithm-main-stages_cat-to-numberic-docpage/</a></p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets">2</span></dt>
<dd><p>CatBoost: unbiased boosting with categorical features, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://arxiv.org/abs/1706.09516">https://arxiv.org/abs/1706.09516</a></p>
<dl class="py method">
<dt id="ballet.eng.external.CatBoostEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/cat_boost.html#CatBoostEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CatBoostEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CatBoostEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/cat_boost.html#CatBoostEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CatBoostEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CatBoostEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/cat_boost.html#CatBoostEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CatBoostEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target information (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.CategoricalVariableImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">CategoricalVariableImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imputation_method</span><span class="o">=</span><span class="default_value">'missing'</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">'Missing'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_object</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#CategoricalVariableImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CategoricalVariableImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseImputer</span></code></p>
<p>The CategoricalVariableImputer() replaces missing data in categorical variables
by the string ‘Missing’ or by the most frequent category.</p>
<p>The CategoricalVariableImputer() works only with categorical variables.</p>
<p>The user can pass a list with the variables to be imputed. Alternatively,
the CategoricalVariableImputer() will automatically find and select all
variables of type object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imputation_method</strong> (<em>str</em><em>, </em><em>default=missing</em>) – Desired method of imputation. Can be ‘frequent’ or ‘missing’.</p></li>
<li><p><strong>fill_value</strong> (<em>str</em><em>, </em><em>default='Missing'</em>) – Only used when imputation_method=’missing’. Can be used to set a
user-defined value to replace the missing data.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables to be imputed. If None, the imputer will find and
select all object type variables.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) – <p>If working with numerical variables cast as object, decide
whether to return the variables as numeric or re-cast them as object.
Note that pandas will re-cast them automatically as numeric after the
transformation with the mode.</p>
<p>Tip: return the variables as object if planning to do categorical encoding
with feature-engine.</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.CategoricalVariableImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#CategoricalVariableImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CategoricalVariableImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the most frequent category if the imputation method is set to frequent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the selected variables.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.CategoricalVariableImputer.imputer_dict_">
<code class="sig-name descname">imputer_dict_</code><a class="headerlink" href="#ballet.eng.external.CategoricalVariableImputer.imputer_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary mapping each variable to the most frequent category, or to
the value ‘Missing’ depending on the imputation_method. The most frequent
category is calculated when fitting the transformer.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CategoricalVariableImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#CategoricalVariableImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CategoricalVariableImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.CountEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">CountEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'count'</span></em>, <em class="sig-param"><span class="n">min_group_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">combine_min_nan_groups</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_group_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/count.html#CountEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.CountEncoder.combine_min_categories">
<code class="sig-name descname">combine_min_categories</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/count.html#CountEncoder.combine_min_categories"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountEncoder.combine_min_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine small categories into a single category.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CountEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/count.html#CountEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CountEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/count.html#CountEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.CountFrequencyCategoricalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">CountFrequencyCategoricalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encoding_method</span><span class="o">=</span><span class="default_value">'count'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#CountFrequencyCategoricalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountFrequencyCategoricalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseCategoricalTransformer</span></code></p>
<p>The CountFrequencyCategoricalEncoder() replaces categories by the count of
observations per category or by the percentage of observations per category.</p>
<p>For example in the variable colour, if 10 observations are blue, blue will
be replaced by 10. Alternatively, if 10% of the observations are blue, blue
will be replaced by 0.1.</p>
<p>The CountFrequencyCategoricalEncoder() will encode only categorical variables
(type ‘object’). A list of variables to be encoded can be passed as argument.
Alternatively, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first maps the categories to the numbers (counts or frequencies)
for each variable (fit).</p>
<p>The encoder then transforms the categories to those mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default='count'</em>) – <p>Desired method of encoding.</p>
<p>’count’: number of observations per category</p>
<p>’frequency’: percentage of observations per category</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em>) – The list of categorical variables that will be encoded. If None, the
encoder will find and transform all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.CountFrequencyCategoricalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#CountFrequencyCategoricalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountFrequencyCategoricalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the counts or frequencies which will be used to replace the categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
The user can pass the entire dataframe.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.CountFrequencyCategoricalEncoder.encoder_dict_">
<code class="sig-name descname">encoder_dict_</code><a class="headerlink" href="#ballet.eng.external.CountFrequencyCategoricalEncoder.encoder_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary containing the {category: count / frequency} pairs for
each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CountFrequencyCategoricalEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#CountFrequencyCategoricalEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountFrequencyCategoricalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_transformed</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The transformed dataframe.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The un-transformed dataframe, that is, containing the original values
of the categorical variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.CountFrequencyCategoricalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#CountFrequencyCategoricalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.CountFrequencyCategoricalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe containing categories replaced by numbers.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.DFSTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">DFSTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">entities</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">relationships</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">entityset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target_entity</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">agg_primitives</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">trans_primitives</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allowed_paths</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_depth</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">ignore_entities</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ignore_variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seed_features</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_contains</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_exact</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where_primitives</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_features</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/featuretools_sklearn_transformer/transformer.html#DFSTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DFSTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Transformer using Scikit-Learn interface for Pipeline uses.</p>
<dl class="py method">
<dt id="ballet.eng.external.DFSTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cuttof_time_ids</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/featuretools_sklearn_transformer/transformer.html#DFSTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DFSTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for DFS</p>
<p>Calculates a feature matrix and features given a dictionary of
entities and a list of relationships.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cuttof_time_ids</strong> (<em>list | DataFrame</em>) – Instances filtered to
calculate features on.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">synthesis.dfs()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.DFSTransformer.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/featuretools_sklearn_transformer/transformer.html#DFSTransformer.get_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DFSTransformer.get_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.DFSTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cuttof_time_ids</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/featuretools_sklearn_transformer/transformer.html#DFSTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DFSTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for calculate_feature_matix</p>
<p>Calculates a matrix for a given set of instance ids and calculation
times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cuttof_time_ids</strong> (<em>list | DataFrame</em>) – Instances filtered to
calculate features on.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">computational_backends.calculate_feature_matrix()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.DecisionTreeDiscretiser">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">DecisionTreeDiscretiser</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cv</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">scoring</span><span class="o">=</span><span class="default_value">'neg_mean_squared_error'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">param_grid</span><span class="o">=</span><span class="default_value">{'max_depth': [1, 2, 3, 4]}</span></em>, <em class="sig-param"><span class="n">regression</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#DecisionTreeDiscretiser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DecisionTreeDiscretiser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The DecisionTreeDiscretiser() divides continuous numerical variables into discrete,
finite, values estimated by a decision tree.</p>
<p>The methods is inspired by the following article from the winners of the KDD
2009 competition:
<a class="reference external" href="http://www.mtome.com/Publications/CiML/CiML-v3-book.pdf">http://www.mtome.com/Publications/CiML/CiML-v3-book.pdf</a></p>
<p>At the moment, this transformer only works for binary classification or
regression. Multi-class classification is not supported.</p>
<p>The DecisionTreeDiscretiser() works only with numerical variables.
A list of variables can be passed as an argument. Alternatively, the
discretiser will automatically select all numerical variables.</p>
<p>The DecisionTreeDiscretiser() first trains a decision tree for each variable,
fit.</p>
<p>The DecisionTreeDiscretiser() then transforms the variables, that is,
makes predictions based on the variable values, using the trained decision
tree, transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cv</strong> (<em>int</em><em>, </em><em>default=3</em>) – Desired number of cross-validation fold to be used to fit the decision
tree.</p></li>
<li><p><strong>scoring</strong> (<em>str</em><em>, </em><em>default='neg_mean_squared_error'</em>) – Desired metric to optimise the performance for the tree. Comes from
sklearn metrics. See DecisionTreeRegressor or DecisionTreeClassifier
model evaluation documentation for more options:
<a class="reference external" href="https://scikit-learn.org/stable/modules/model_evaluation.html">https://scikit-learn.org/stable/modules/model_evaluation.html</a></p></li>
<li><p><strong>variables</strong> (<em>list</em>) – The list of numerical variables that will be transformed. If None, the
discretiser will automatically select all numerical type variables.</p></li>
<li><p><strong>regression</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – Indicates whether the discretiser should train a regression or a classification
decision tree.</p></li>
<li><p><strong>param_grid</strong> (<em>dictionary</em><em>, </em><em>default={'max_depth':</em><em> [</em><em>1</em><em>,</em><em>2</em><em>,</em><em>3</em><em>,</em><em>4</em><em>]</em><em>}</em>) – The list of parameters over which the decision tree should be optimised
during the grid search. The param_grid can contain any of the permitted
parameters for Scikit-learn’s DecisionTreeRegressor() or
DecisionTreeClassifier().</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>default=None</em>) – The random_state to initialise the training of the decision tree. It is one
of the parameters of the Scikit-learn’s DecisionTreeRegressor() or
DecisionTreeClassifier(). For reproducibility it is recommended to set
the random_state to an integer.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.DecisionTreeDiscretiser.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#DecisionTreeDiscretiser.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DecisionTreeDiscretiser.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the decision trees. One tree per variable to be transformed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas series.</em>) – Target variable. Required to train the decision tree.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.DecisionTreeDiscretiser.binner_dict_">
<code class="sig-name descname">binner_dict_</code><a class="headerlink" href="#ballet.eng.external.DecisionTreeDiscretiser.binner_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {variable: fitted tree} pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.DecisionTreeDiscretiser.scores_dict_">
<code class="sig-name descname">scores_dict_</code><a class="headerlink" href="#ballet.eng.external.DecisionTreeDiscretiser.scores_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The score of the best decision tree, over the train set.
Provided in case the user wishes to understand the performance of the
decision tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.DecisionTreeDiscretiser.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#DecisionTreeDiscretiser.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DecisionTreeDiscretiser.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the predictions of the tree, based of the variable original
values. The tree outcome is finite, aka, discrete.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe with transformed variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.DifferenceTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">DifferenceTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">period</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#DifferenceTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DifferenceTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.DifferenceTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#DifferenceTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DifferenceTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.DifferenceTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#DifferenceTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DifferenceTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.DifferenceTransformer.needs_refit">
<code class="sig-name descname">needs_refit</code><em class="property"> = True</em><a class="headerlink" href="#ballet.eng.external.DifferenceTransformer.needs_refit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.DifferenceTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">refit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#DifferenceTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.DifferenceTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.EndTailImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">EndTailImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distribution</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">tail</span><span class="o">=</span><span class="default_value">'right'</span></em>, <em class="sig-param"><span class="n">fold</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#EndTailImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EndTailImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseImputer</span></code></p>
<p>The EndTailImputer() transforms features by replacing missing data by a
value at either tail of the distribution.</p>
<p>The EndTailImputer() works only with numerical variables.</p>
<p>The user can indicate the variables to be imputed in a list. Alternatively, the
EndTailImputer() will automatically find and select all variables of type numeric.</p>
<p>The imputer first calculates the values at the end of the distribution for each variable
(fit). The values at the end of the distribution are determined using the Gaussian limits,
the the IQR proximity rule limits, or a factor of the maximum value:</p>
<dl>
<dt>Gaussian limits:</dt><dd><p>right tail: mean + 3*std</p>
<p>left tail: mean - 3*std</p>
</dd>
<dt>IQR limits:</dt><dd><p>right tail: 75th quantile + 3*IQR</p>
<p>left tail:  25th quantile - 3*IQR</p>
</dd>
</dl>
<p>where IQR is the inter-quartile range = 75th quantile - 25th quantile</p>
<dl>
<dt>Maximum value:</dt><dd><p>right tail: max * 3</p>
<p>left tail: not applicable</p>
</dd>
</dl>
<p>You can change the factor that multiplies the std, IQR or the maximum value
using the parameter ‘fold’.</p>
<p>The imputer then replaces the missing data with the estimated values (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distribution</strong> (<em>str</em><em>, </em><em>default=gaussian</em>) – <p>Method to be used to find the replacement values. Can take ‘gaussian’,
‘skewed’ or ‘max’.</p>
<p>gaussian: the imputer will use the Gaussian limits to find the values
to replace missing data.</p>
<p>skewed: the imputer will use the IQR limits to find the values to replace
missing data.</p>
<p>max: the imputer will use the maximum values to replace missing data. Note
that if ‘max’ is passed, the parameter ‘tail’ is ignored.</p>
</p></li>
<li><p><strong>tail</strong> (<em>str</em><em>, </em><em>default=right</em>) – Indicates if the values to replace missing data should be selected from the right
or left tail of the variable distribution. Can take values ‘left’ or ‘right’.</p></li>
<li><p><strong>fold</strong> (<em>int</em><em>, </em><em>default=3</em>) – Factor to multiply the std, the IQR or the Max values. Recommended values
are 2 or 3 for Gaussian, or 1.5 or 3 for skewed.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables to be imputed. If None, the imputer will find and
select all variables of type numeric.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.EndTailImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#EndTailImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EndTailImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the values at the end of the variable distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
The user can pass the entire dataframe, not just the variables that need imputation.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.EndTailImputer.imputer_dict_">
<code class="sig-name descname">imputer_dict_</code><a class="headerlink" href="#ballet.eng.external.EndTailImputer.imputer_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the values at the end of the distribution
per variable. These values will be used by the imputer to replace missing
data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.EndTailImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#EndTailImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EndTailImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.EqualFrequencyDiscretiser">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">EqualFrequencyDiscretiser</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_object</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_boundaries</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#EqualFrequencyDiscretiser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EqualFrequencyDiscretiser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The EqualFrequencyDiscretiser() divides continuous numerical variables
into contiguous equal frequency intervals, that is, intervals that contain
approximately the same proportion of observations.</p>
<p>The interval limits are determined using pandas.qcut(), in other words,
the interval limits are determined by the quantiles. The number of intervals,
i.e., the number of quantiles in which the variable should be divided is
determined by the user.</p>
<p>The EqualFrequencyDiscretiser() works only with numerical variables.
A list of variables can be passed as argument. Alternatively, the discretiser
will automatically select and transform all numerical variables.</p>
<p>The EqualFrequencyDiscretiser() first finds the boundaries for the intervals or
quantiles for each variable, fit.</p>
<p>Then it transforms the variables, that is, it sorts the values into the intervals,
transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>int</em><em>, </em><em>default=10</em>) – Desired number of equal frequency intervals / bins. In other words the
number of quantiles in which the variables should be divided.</p></li>
<li><p><strong>variables</strong> (<em>list</em>) – The list of numerical variables that will be discretised. If None, the
EqualFrequencyDiscretiser() will select all numerical variables.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether the numbers in the discrete variable should be returned as
numeric or as object. The decision is made by the user based on
whether they would like to proceed the engineering of the variable as
if it was numerical or categorical.</p></li>
<li><p><strong>return_boundaries</strong> (<em>bool</em><em>, </em><em>default=False</em>) – whether the output should be the interval boundaries. If True, it returns
the interval boundaries. If False, it returns integers.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.EqualFrequencyDiscretiser.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#EqualFrequencyDiscretiser.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EqualFrequencyDiscretiser.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the limits of the equal frequency intervals, that is the
quantiles for each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to be transformed.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.EqualFrequencyDiscretiser.binner_dict_">
<code class="sig-name descname">binner_dict_</code><a class="headerlink" href="#ballet.eng.external.EqualFrequencyDiscretiser.binner_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {variable: interval limits} pairs used
to sort the values into discrete intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.EqualFrequencyDiscretiser.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#EqualFrequencyDiscretiser.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EqualFrequencyDiscretiser.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the variable values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The transformed data with the discrete variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.EqualWidthDiscretiser">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">EqualWidthDiscretiser</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bins</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_object</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_boundaries</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#EqualWidthDiscretiser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EqualWidthDiscretiser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The EqualWidthDiscretiser() divides continuous numerical variables into
intervals of the same width, that is, equidistant intervals. Note that the
proportion of observations per interval may vary.</p>
<p>The interval limits are determined using pandas.cut(). The number of intervals
in which the variable should be divided must be indicated by the user.</p>
<p>The EqualWidthDiscretiser() works only with numerical variables.
A list of variables can be passed as argument. Alternatively, the discretiser
will automatically select all numerical variables.</p>
<p>The EqualWidthDiscretiser() first finds the boundaries for the intervals for
each variable, fit.</p>
<p>Then, it transforms the variables, that is, sorts the values into the intervals,
transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>default=10</em>) – Desired number of equal width intervals / bins.</p></li>
<li><p><strong>variables</strong> (<em>list</em>) – The list of numerical variables to transform. If None, the
discretiser will automatically select all numerical type variables.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether the numbers in the discrete variable should be returned as
numeric or as object. The decision should be made by the user based on
whether they would like to proceed the engineering of the variable as
if it was numerical or categorical.</p></li>
<li><p><strong>return_boundaries</strong> (<em>bool</em><em>, </em><em>default=False</em>) – whether the output should be the interval boundaries. If True, it returns
the interval boundaries. If False, it returns integers.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.EqualWidthDiscretiser.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#EqualWidthDiscretiser.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EqualWidthDiscretiser.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the boundaries of the equal width intervals / bins for each
variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to transform.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.EqualWidthDiscretiser.binner_dict_">
<code class="sig-name descname">binner_dict_</code><a class="headerlink" href="#ballet.eng.external.EqualWidthDiscretiser.binner_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {variable: interval boundaries} pairs used
to transform each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.EqualWidthDiscretiser.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#EqualWidthDiscretiser.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.EqualWidthDiscretiser.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the variable values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The transformed data with the discrete variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.FeatureAugmenter">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">FeatureAugmenter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default_fc_parameters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kind_to_fc_parameters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">column_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">column_sort</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">column_kind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">column_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timeseries_container</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n_jobs</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">show_warnings</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">disable_progressbar</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">impute_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">profile</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">profiling_filename</span><span class="o">=</span><span class="default_value">'profile.txt'</span></em>, <em class="sig-param"><span class="n">profiling_sorting</span><span class="o">=</span><span class="default_value">'cumulative'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tsfresh/transformers/feature_augmenter.html#FeatureAugmenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FeatureAugmenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Sklearn-compatible estimator, for calculating and adding many features calculated from a given time series
to the data. It is basically a wrapper around <code class="xref py py-func docutils literal notranslate"><span class="pre">extract_features()</span></code>.</p>
<p>The features include basic ones like min, max or median, and advanced features like fourier
transformations or statistical tests. For a list of all possible features, see the module
<code class="xref py py-mod docutils literal notranslate"><span class="pre">feature_calculators</span></code>. The column name of each added feature contains the name
of the function of that module, which was used for the calculation.</p>
<p>For this estimator, two datasets play a crucial role:</p>
<ol class="arabic simple">
<li><p>the time series container with the timeseries data. This container (for the format see <span class="xref std std-ref">data-formats-label</span>)
contains the data which is used for calculating the
features. It must be groupable by ids which are used to identify which feature should be attached to which row
in the second dataframe:</p></li>
<li><p>the input data, where the features will be added to.</p></li>
</ol>
<p>Imagine the following situation: You want to classify 10 different financial shares and you have their development
in the last year as a time series. You would then start by creating features from the metainformation of the
shares, e.g. how long they were on the market etc. and filling up a table - the features of one stock in one row.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fill in the information of the stocks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;started_since_days&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># add a feature</span>
</pre></div>
</div>
<p>You can then extract all the features from the time development of the shares, by using this estimator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">time_series</span> <span class="o">=</span> <span class="n">read_in_timeseries</span><span class="p">()</span> <span class="c1"># get the development of the shares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tsfresh.transformers</span> <span class="kn">import</span> <span class="n">FeatureAugmenter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">augmenter</span> <span class="o">=</span> <span class="n">FeatureAugmenter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">augmenter</span><span class="o">.</span><span class="n">set_timeseries_container</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_with_time_series_features</span> <span class="o">=</span> <span class="n">augmenter</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>The settings for the feature calculation can be controlled with the settings object.
If you pass <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default settings are used.
Please refer to <code class="xref py py-class docutils literal notranslate"><span class="pre">ComprehensiveFCParameters</span></code> for
more information.</p>
<p>This estimator does not select the relevant features, but calculates and adds all of them to the DataFrame. See the
<code class="xref py py-class docutils literal notranslate"><span class="pre">RelevantFeatureAugmenter</span></code> for calculating and selecting
features.</p>
<p>For a description what the parameters column_id, column_sort, column_kind and column_value mean, please see
<code class="xref py py-mod docutils literal notranslate"><span class="pre">extraction</span></code>.</p>
<dl class="py method">
<dt id="ballet.eng.external.FeatureAugmenter.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tsfresh/transformers/feature_augmenter.html#FeatureAugmenter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FeatureAugmenter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>The fit function is not needed for this estimator. It just does nothing and is here for compatibility reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Any</em>) – Unneeded.</p></li>
<li><p><strong>y</strong> (<em>Any</em>) – Unneeded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The estimator instance itself</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ballet.eng.external.FeatureAugmenter" title="ballet.eng.external.FeatureAugmenter">FeatureAugmenter</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.FeatureAugmenter.set_timeseries_container">
<code class="sig-name descname">set_timeseries_container</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timeseries_container</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tsfresh/transformers/feature_augmenter.html#FeatureAugmenter.set_timeseries_container"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FeatureAugmenter.set_timeseries_container" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the timeseries, with which the features will be calculated. For a format of the time series container,
please refer to <code class="xref py py-mod docutils literal notranslate"><span class="pre">extraction</span></code>. The timeseries must contain the same indices
as the later DataFrame, to which the features will be added (the one you will pass to <a class="reference internal" href="#ballet.eng.external.FeatureAugmenter.transform" title="ballet.eng.external.FeatureAugmenter.transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">transform()</span></code></a>). You
can call this function as often as you like, to change the timeseries later (e.g. if you want to extract for
different ids).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeseries_container</strong> (<em>pandas.DataFrame</em><em> or </em><em>dict</em>) – The timeseries as a pandas.DataFrame or a dict. See
<code class="xref py py-mod docutils literal notranslate"><span class="pre">extraction</span></code> for the format.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.FeatureAugmenter.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tsfresh/transformers/feature_augmenter.html#FeatureAugmenter.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FeatureAugmenter.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the features calculated using the timeseries_container and add them to the corresponding rows in the input
pandas.DataFrame X.</p>
<p>To save some computing time, you should only include those time serieses in the container, that you
need. You can set the timeseries container with the method <a class="reference internal" href="#ballet.eng.external.FeatureAugmenter.set_timeseries_container" title="ballet.eng.external.FeatureAugmenter.set_timeseries_container"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_timeseries_container()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas.DataFrame</em>) – the DataFrame to which the calculated timeseries features will be added. This is <em>not</em> the
dataframe with the timeseries itself.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The input DataFrame, but with added features.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.FourierTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">FourierTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">period</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">max_order</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">step_size</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#FourierTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FourierTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.FourierTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#FourierTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FourierTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.FourierTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#FourierTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FourierTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.FunctionTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">FunctionTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_function_transformer.html#FunctionTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FunctionTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Constructs a transformer from an arbitrary callable.</p>
<p>A FunctionTransformer forwards its X (and optionally y) arguments to a
user-defined function or function object and returns the result of this
function. This is useful for stateless transformations such as taking the
log of frequencies, doing custom scaling, etc.</p>
<p>Note: If a lambda is used as the function, then the resulting
transformer will not be pickleable.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17.</span></p>
</div>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> (<em>callable</em><em>, </em><em>optional default=None</em>) – The callable to use for the transformation. This will be passed
the same arguments as transform, with args and kwargs forwarded.
If func is None, then func will be the identity function.</p></li>
<li><p><strong>inverse_func</strong> (<em>callable</em><em>, </em><em>optional default=None</em>) – The callable to use for the inverse transformation. This will be
passed the same arguments as inverse transform, with args and
kwargs forwarded. If inverse_func is None, then inverse_func
will be the identity function.</p></li>
<li><p><strong>validate</strong> (<em>bool</em><em>, </em><em>optional default=False</em>) – <p>Indicate that the input X array should be checked before calling
<code class="docutils literal notranslate"><span class="pre">func</span></code>. The possibilities are:</p>
<ul>
<li><p>If False, there is no input validation.</p></li>
<li><p>If True, then X will be converted to a 2-dimensional NumPy array or
sparse matrix. If the conversion is not possible an exception is
raised.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.22: </span>The default of <code class="docutils literal notranslate"><span class="pre">validate</span></code> changed from True to False.</p>
</div>
</p></li>
<li><p><strong>accept_sparse</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Indicate that func accepts a sparse matrix as input. If validate is
False, this has no effect. Otherwise, if accept_sparse is false,
sparse matrix inputs will cause an exception to be raised.</p></li>
<li><p><strong>check_inverse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – <p>Whether to check that or <code class="docutils literal notranslate"><span class="pre">func</span></code> followed by <code class="docutils literal notranslate"><span class="pre">inverse_func</span></code> leads to
the original inputs. It can be used for a sanity check, raising a
warning when the condition is not fulfilled.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>kw_args</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Dictionary of additional keyword arguments to pass to func.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.</span></p>
</div>
</p></li>
<li><p><strong>inv_kw_args</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Dictionary of additional keyword arguments to pass to inverse_func.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.</span></p>
</div>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">FunctionTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[0.       , 0.6931...],</span>
<span class="go">       [1.0986..., 1.3862...]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.FunctionTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_function_transformer.html#FunctionTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FunctionTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit transformer by checking X.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">validate</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">X</span></code> will be checked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.FunctionTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_function_transformer.html#FunctionTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FunctionTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X using the inverse function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.FunctionTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_function_transformer.html#FunctionTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.FunctionTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X using the forward function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.GLMMEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">GLMMEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">randomized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">binomial_target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/glmm.html#GLMMEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.GLMMEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>Generalized linear mixed model.</p>
<p>This is a supervised encoder similar to TargetEncoder or MEstimateEncoder, but there are some advantages:
1) Solid statistical theory behind the technique. Mixed effects models are a mature branch of statistics.
2) No hyper-parameters to tune. The amount of shrinkage is automatically determined through the estimation process.
In short, the less observations a category has and/or the more the outcome varies for a category
then the higher the regularization towards “the prior” or “grand mean”.
3) The technique is applicable for both continuous and binomial targets. If the target is continuous,
the encoder returns regularized difference of the observation’s category from the global mean.
If the target is binomial, the encoder returns regularized log odds per category.</p>
<p>In comparison to JamesSteinEstimator, this encoder utilizes generalized linear mixed models from statsmodels library.</p>
<p>Note: This is an alpha implementation. The API of the method may change in the future.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop encoded columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which returns 0.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which returns 0.</p></li>
<li><p><strong>randomized</strong> (<em>bool</em><em>,</em>) – adds normal (Gaussian) distribution noise into training data in order to decrease overfitting (testing data are untouched).</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – standard deviation (spread or “width”) of the normal distribution.</p></li>
<li><p><strong>binomial_target</strong> (<em>bool</em>) – if True, the target must be binomial with values {0, 1} and Binomial mixed model is used.
If False, the target must be continuous and Linear mixed model is used.
If None (the default), a heuristic is applied to estimate the target type.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span> <span class="o">&gt;</span> <span class="mf">22.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">GLMMEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets">1</span></dt>
<dd><p>Data Analysis Using Regression and Multilevel/Hierarchical Models, page 253, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://faculty.psau.edu.sa/filedownload/doc-12-pdf-a1997d0d31f84d13c1cdc44ac39a8f2c-original.pdf">https://faculty.psau.edu.sa/filedownload/doc-12-pdf-a1997d0d31f84d13c1cdc44ac39a8f2c-original.pdf</a></p>
<dl class="py method">
<dt id="ballet.eng.external.GLMMEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/glmm.html#GLMMEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.GLMMEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and binary y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Binary target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.GLMMEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/glmm.html#GLMMEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.GLMMEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.GLMMEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/glmm.html#GLMMEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.GLMMEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<p>When the data are used for model training, it is important to also pass the target in order to apply leave one out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target information (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.GaussianRandomProjection">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">GaussianRandomProjection</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/random_projection.html#GaussianRandomProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.GaussianRandomProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.random_projection.BaseRandomProjection</span></code></p>
<p>Reduce dimensionality through Gaussian random projection</p>
<p>The components of the random matrix are drawn from N(0, 1 / n_components).</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.13.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_components</strong> (<em>int</em><em> or </em><em>'auto'</em><em>, </em><em>optional</em><em> (</em><em>default = 'auto'</em><em>)</em>) – <p>Dimensionality of the target projection space.</p>
<p>n_components can be automatically adjusted according to the
number of samples in the dataset and the bound given by the
Johnson-Lindenstrauss lemma. In that case the quality of the
embedding is controlled by the <code class="docutils literal notranslate"><span class="pre">eps</span></code> parameter.</p>
<p>It should be noted that Johnson-Lindenstrauss lemma can yield
very conservative estimated of the required number of components
as it makes no assumption on the structure of the dataset.</p>
</p></li>
<li><p><strong>eps</strong> (<em>strictly positive float</em><em>, </em><em>optional</em><em> (</em><em>default=0.1</em><em>)</em>) – <p>Parameter to control the quality of the embedding according to
the Johnson-Lindenstrauss lemma when n_components is set to
‘auto’.</p>
<p>Smaller values lead to better embedding and higher number of
dimensions (n_components) in the target projection space.</p>
</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Controls the pseudo random number generator used to generate the
projection matrix at fit time.
Pass an int for reproducible output across multiple function calls.
See <span class="xref std std-term">Glossary</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.GaussianRandomProjection.n_components_">
<code class="sig-name descname">n_components_</code><a class="headerlink" href="#ballet.eng.external.GaussianRandomProjection.n_components_" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete number of components computed when n_components=”auto”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.GaussianRandomProjection.components_">
<code class="sig-name descname">components_</code><a class="headerlink" href="#ballet.eng.external.GaussianRandomProjection.components_" title="Permalink to this definition">¶</a></dt>
<dd><p>Random matrix used for the projection.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy array of shape [n_components, n_features]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.random_projection</span> <span class="kn">import</span> <span class="n">GaussianRandomProjection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">GaussianRandomProjection</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_new</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_new</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3947)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ballet.eng.external.SparseRandomProjection" title="ballet.eng.external.SparseRandomProjection"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseRandomProjection</span></code></a></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.HashingEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">HashingEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_process</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">max_sample</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">n_components</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">hash_method</span><span class="o">=</span><span class="default_value">'md5'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/hashing.html#HashingEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HashingEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>A multivariate hashing implementation with configurable dimensionality/precision.</p>
<p>The advantage of this encoder is that it does not maintain a dictionary of observed categories.
Consequently, the encoder does not grow in size and accepts new values during data scoring
by design.</p>
<p>It’s important to read about how max_process &amp; max_sample work
before setting them manually, inappropriate setting slows down encoding.</p>
<p>Default value of ‘max_process’ is 1 on Windows because multiprocessing might cause issues, see in :
<a class="reference external" href="https://github.com/scikit-learn-contrib/categorical-encoding/issues/215">https://github.com/scikit-learn-contrib/categorical-encoding/issues/215</a>
<a class="reference external" href="https://docs.python.org/2/library/multiprocessing.html?highlight=process#windows">https://docs.python.org/2/library/multiprocessing.html?highlight=process#windows</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>hash_method</strong> (<em>str</em>) – which hashing method to use. Any method from hashlib works.</p></li>
<li><p><strong>max_process</strong> (<em>int</em>) – how many processes to use in transform(). Limited in range(1, 64).
By default, it uses half of the logical CPUs.
For example, 4C4T makes max_process=2, 4C8T makes max_process=4.
Set it larger if you have a strong CPU.
It is not recommended to set it larger than is the count of the
logical CPUs as it will actually slow down the encoding.</p></li>
<li><p><strong>max_sample</strong> (<em>int</em>) – how many samples to encode by each process at a time.
This setting is useful on low memory machines.
By default, max_sample=(all samples num)/(max_process).
For example, 4C8T CPU with 100,000 samples makes max_sample=25,000,
6C12T CPU with 100,000 samples makes max_sample=16,666.
It is not recommended to set it larger than the default value.</p></li>
<li><p><strong>n_components</strong> (<em>int</em>) – how many bits to use to represent the feature. By default we use 8 bits.
For high-cardinality features, consider using up-to 32 bits.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders.hashing</span> <span class="kn">import</span> <span class="n">HashingEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">he</span> <span class="o">=</span> <span class="n">HashingEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">he</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 19 columns):</span>
<span class="go">col_0      506 non-null int64</span>
<span class="go">col_1      506 non-null int64</span>
<span class="go">col_2      506 non-null int64</span>
<span class="go">col_3      506 non-null int64</span>
<span class="go">col_4      506 non-null int64</span>
<span class="go">col_5      506 non-null int64</span>
<span class="go">col_6      506 non-null int64</span>
<span class="go">col_7      506 non-null int64</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(11), int64(8)</span>
<span class="go">memory usage: 75.2 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">1</span></dt>
<dd><p>Feature Hashing for Large Scale Multitask Learning, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://alex.smola.org/papers/2009/Weinbergeretal09.pdf">https://alex.smola.org/papers/2009/Weinbergeretal09.pdf</a>
.. [2] Don’t be tricked by the Hashing Trick, from
<a class="reference external" href="https://booking.ai/dont-be-tricked-by-the-hashing-trick-192a6aae3087">https://booking.ai/dont-be-tricked-by-the-hashing-trick-192a6aae3087</a></p>
<dl class="py method">
<dt id="ballet.eng.external.HashingEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/hashing.html#HashingEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HashingEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HashingEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/hashing.html#HashingEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HashingEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HashingEncoder.hashing_trick">
<em class="property">static </em><code class="sig-name descname">hashing_trick</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">hashing_method</span><span class="o">=</span><span class="default_value">'md5'</span></em>, <em class="sig-param"><span class="n">N</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">make_copy</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/hashing.html#HashingEncoder.hashing_trick"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HashingEncoder.hashing_trick" title="Permalink to this definition">¶</a></dt>
<dd><p>A basic hashing implementation with configurable dimensionality/precision</p>
<p>Performs the hashing trick on a pandas dataframe, <cite>X</cite>, using the hashing method from hashlib
identified by <cite>hashing_method</cite>.  The number of output dimensions (<cite>N</cite>), and columns to hash (<cite>cols</cite>) are
also configurable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_in</strong> (<em>pandas dataframe</em>) – description text</p></li>
<li><p><strong>hashing_method</strong> (<em>string</em><em>, </em><em>optional</em>) – description text</p></li>
<li><p><strong>N</strong> (<em>int</em><em>, </em><em>optional</em>) – description text</p></li>
<li><p><strong>cols</strong> (<em>list</em><em>, </em><em>optional</em>) – description text</p></li>
<li><p><strong>make_copy</strong> (<em>bool</em><em>, </em><em>optional</em>) – description text</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – A hashing encoded dataframe.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dataframe</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Cite the relevant literature, e.g. <a href="#id59"><span class="problematic" id="id7">[1]_</span></a>.  You may also cite these
references in the notes section above.
.. [1] Kilian Weinberger; Anirban Dasgupta; John Langford; Alex Smola; Josh Attenberg (2009). Feature Hashing
for Large Scale Multitask Learning. Proc. ICML.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HashingEncoder.require_data">
<em class="property">static </em><code class="sig-name descname">require_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">data_lock</span></em>, <em class="sig-param"><span class="n">new_start</span></em>, <em class="sig-param"><span class="n">done_index</span></em>, <em class="sig-param"><span class="n">hashing_parts</span></em>, <em class="sig-param"><span class="n">cols</span></em>, <em class="sig-param"><span class="n">process_index</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/hashing.html#HashingEncoder.require_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HashingEncoder.require_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HashingEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/hashing.html#HashingEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HashingEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Call _transform() if you want to use single CPU with all samples</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.HelmertEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">HelmertEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/helmert.html#HelmertEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HelmertEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Helmert contrast coding for encoding categorical features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has unknown categories.  This can cause
unexpected changes in dimension in some cases.</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has nan values.  This can cause
unexpected changes in dimension in some cases.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">HelmertEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">],</span> <span class="n">handle_unknown</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="n">handle_missing</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 21 columns):</span>
<span class="go">intercept    506 non-null int64</span>
<span class="go">CRIM         506 non-null float64</span>
<span class="go">ZN           506 non-null float64</span>
<span class="go">INDUS        506 non-null float64</span>
<span class="go">CHAS_0       506 non-null float64</span>
<span class="go">NOX          506 non-null float64</span>
<span class="go">RM           506 non-null float64</span>
<span class="go">AGE          506 non-null float64</span>
<span class="go">DIS          506 non-null float64</span>
<span class="go">RAD_0        506 non-null float64</span>
<span class="go">RAD_1        506 non-null float64</span>
<span class="go">RAD_2        506 non-null float64</span>
<span class="go">RAD_3        506 non-null float64</span>
<span class="go">RAD_4        506 non-null float64</span>
<span class="go">RAD_5        506 non-null float64</span>
<span class="go">RAD_6        506 non-null float64</span>
<span class="go">RAD_7        506 non-null float64</span>
<span class="go">TAX          506 non-null float64</span>
<span class="go">PTRATIO      506 non-null float64</span>
<span class="go">B            506 non-null float64</span>
<span class="go">LSTAT        506 non-null float64</span>
<span class="go">dtypes: float64(20), int64(1)</span>
<span class="go">memory usage: 83.1 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">1</span></dt>
<dd><p>Contrast Coding Systems for Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/</a></p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">2</span></dt>
<dd><p>Gregory Carey (2003). Coding Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf">http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf</a></p>
<dl class="py method">
<dt id="ballet.eng.external.HelmertEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/helmert.html#HelmertEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HelmertEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HelmertEncoder.fit_helmert_coding">
<em class="property">static </em><code class="sig-name descname">fit_helmert_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">col</span></em>, <em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="n">handle_missing</span></em>, <em class="sig-param"><span class="n">handle_unknown</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/helmert.html#HelmertEncoder.fit_helmert_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HelmertEncoder.fit_helmert_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HelmertEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/helmert.html#HelmertEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HelmertEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HelmertEncoder.helmert_coding">
<em class="property">static </em><code class="sig-name descname">helmert_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">mapping</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/helmert.html#HelmertEncoder.helmert_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HelmertEncoder.helmert_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HelmertEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/helmert.html#HelmertEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HelmertEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.HorizonTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">HorizonTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">horizon</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#HorizonTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HorizonTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.HorizonTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#HorizonTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HorizonTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HorizonTransformer.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#HorizonTransformer.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HorizonTransformer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix</em><em>, </em><em>dataframe} of shape</em><em>                 (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
<li><p><strong>y</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Target values.</p></li>
<li><p><strong>**fit_params</strong> (<em>dict</em>) – Additional fit parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_new</strong> – Transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray array of shape (n_samples, n_features_new)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HorizonTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#HorizonTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HorizonTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.HorizonTransformer.needs_refit">
<code class="sig-name descname">needs_refit</code><em class="property"> = True</em><a class="headerlink" href="#ballet.eng.external.HorizonTransformer.needs_refit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.HorizonTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">refit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#HorizonTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.HorizonTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.HorizonTransformer.y_only">
<code class="sig-name descname">y_only</code><em class="property"> = True</em><a class="headerlink" href="#ballet.eng.external.HorizonTransformer.y_only" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.IntegratedTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">IntegratedTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_lags</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">pred_stride</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#IntegratedTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.IntegratedTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.IntegratedTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#IntegratedTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.IntegratedTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.IntegratedTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#IntegratedTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.IntegratedTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.JamesSteinEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">JamesSteinEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">'independent'</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">randomized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">0.05</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/james_stein.html#JamesSteinEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.JamesSteinEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>James-Stein estimator.</p>
<p>For feature value <cite>i</cite>, James-Stein estimator returns a weighted average of:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The mean target value for the observed feature value <cite>i</cite>.</p></li>
<li><p>The mean target value (regardless of the feature value).</p></li>
</ol>
</div></blockquote>
<p>This can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">JS_i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">mean</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span><span class="o">*</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The question is, what should be the weight <cite>B</cite>?
If we put too much weight on the conditional mean value, we will overfit.
If we put too much weight on the global mean, we will underfit.
The canonical solution in machine learning is to perform cross-validation.
However, Charles Stein came with a closed-form solution to the problem.
The intuition is: If the estimate of <cite>mean(y_i)</cite> is unreliable (<cite>y_i</cite> has high variance),
we should put more weight on <cite>mean(y)</cite>. Stein put it into an equation as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span><span class="o">+</span><span class="n">var</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>The only remaining issue is that we do not know <cite>var(y)</cite>, let alone <cite>var(y_i)</cite>.
Hence, we have to estimate the variances. But how can we reliably estimate the
variances, when we already struggle with the estimation of the mean values?!
There are multiple solutions:</p>
<blockquote>
<div><p>1. If we have the same count of observations for each feature value <cite>i</cite> and all
<cite>y_i</cite> are close to each other, we can pretend that all <cite>var(y_i)</cite> are identical.
This is called a pooled model.
2. If the observation counts are not equal, it makes sense to replace the variances
with squared standard errors, which penalize small observation counts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SE</span><span class="o">^</span><span class="mi">2</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">count</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>This is called an independent model.</p>
</div></blockquote>
<p>James-Stein estimator has, however, one practical limitation - it was defined
only for normal distributions. If you want to apply it for binary classification,
which allows only values {0, 1}, it is better to first convert the mean target value
from the bound interval &lt;0,1&gt; into an unbounded interval by replacing mean(y)
with log-odds ratio:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">log</span><span class="o">-</span><span class="n">odds_ratio_i</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span><span class="o">/</span><span class="n">mean</span><span class="p">(</span><span class="n">y_not_i</span><span class="p">))</span>
</pre></div>
</div>
<p>This is called binary model. The estimation of parameters of this model is, however,
tricky and sometimes it fails fatally. In these situations, it is better to use beta
model, which generally delivers slightly worse accuracy than binary model but does
not suffer from fatal failures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop encoded columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which returns the prior probability.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which returns the prior probability.</p></li>
<li><p><strong>model</strong> (<em>str</em>) – options are ‘pooled’, ‘beta’, ‘binary’ and ‘independent’, defaults to ‘independent’.</p></li>
<li><p><strong>randomized</strong> (<em>bool</em><em>,</em>) – adds normal (Gaussian) distribution noise into training data in order to decrease overfitting (testing data are untouched).</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – standard deviation (spread or “width”) of the normal distribution.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">JamesSteinEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets">1</span></dt>
<dd><p>Parametric empirical Bayes inference: Theory and applications, equations 1.19 &amp; 1.20, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://www.jstor.org/stable/2287098">https://www.jstor.org/stable/2287098</a></p>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets">2</span></dt>
<dd><p>Empirical Bayes for multiple sample sizes, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://chris-said.io/2017/05/03/empirical-bayes-for-multiple-sample-sizes/">http://chris-said.io/2017/05/03/empirical-bayes-for-multiple-sample-sizes/</a></p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets">3</span></dt>
<dd><p>Shrinkage Estimation of Log-odds Ratios for Comparing Mobility Tables, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://journals.sagepub.com/doi/abs/10.1177/0081175015570097">https://journals.sagepub.com/doi/abs/10.1177/0081175015570097</a></p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets">4</span></dt>
<dd><p>Stein’s paradox and group rationality, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://www.philos.rug.nl/~romeyn/presentation/">http://www.philos.rug.nl/~romeyn/presentation/</a><a href="#id60"><span class="problematic" id="id61">2017_romeijn_</span></a>-_Paris_Stein.pdf</p>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets">5</span></dt>
<dd><p>Stein’s Paradox in Statistics, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://statweb.stanford.edu/~ckirby/brad/other/Article1977.pdf">http://statweb.stanford.edu/~ckirby/brad/other/Article1977.pdf</a></p>
<dl class="py method">
<dt id="ballet.eng.external.JamesSteinEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/james_stein.html#JamesSteinEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.JamesSteinEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and binary y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Binary target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.JamesSteinEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/james_stein.html#JamesSteinEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.JamesSteinEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.JamesSteinEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/james_stein.html#JamesSteinEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.JamesSteinEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data. When the data are used for model training,
it is important to also pass the target in order to apply leave one out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target information (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.KBinsDiscretizer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">KBinsDiscretizer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_discretization.html#KBinsDiscretizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KBinsDiscretizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Bin continuous data into intervals.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_bins</strong> (<em>int</em><em> or </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_features</em><em>,</em><em>) </em><em>(</em><em>default=5</em><em>)</em>) – The number of bins to produce. Raises ValueError if <code class="docutils literal notranslate"><span class="pre">n_bins</span> <span class="pre">&lt;</span> <span class="pre">2</span></code>.</p></li>
<li><p><strong>encode</strong> (<em>{'onehot'</em><em>, </em><em>'onehot-dense'</em><em>, </em><em>'ordinal'}</em><em>, </em><em>(</em><em>default='onehot'</em><em>)</em>) – <p>Method used to encode the transformed result.</p>
<dl class="simple">
<dt>onehot</dt><dd><p>Encode the transformed result with one-hot encoding
and return a sparse matrix. Ignored features are always
stacked to the right.</p>
</dd>
<dt>onehot-dense</dt><dd><p>Encode the transformed result with one-hot encoding
and return a dense array. Ignored features are always
stacked to the right.</p>
</dd>
<dt>ordinal</dt><dd><p>Return the bin identifier encoded as an integer value.</p>
</dd>
</dl>
</p></li>
<li><p><strong>strategy</strong> (<em>{'uniform'</em><em>, </em><em>'quantile'</em><em>, </em><em>'kmeans'}</em><em>, </em><em>(</em><em>default='quantile'</em><em>)</em>) – <p>Strategy used to define the widths of the bins.</p>
<dl class="simple">
<dt>uniform</dt><dd><p>All bins in each feature have identical widths.</p>
</dd>
<dt>quantile</dt><dd><p>All bins in each feature have the same number of points.</p>
</dd>
<dt>kmeans</dt><dd><p>Values in each bin have the same nearest center of a 1D k-means
cluster.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.KBinsDiscretizer.n_bins_">
<code class="sig-name descname">n_bins_</code><a class="headerlink" href="#ballet.eng.external.KBinsDiscretizer.n_bins_" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bins per feature. Bins whose width are too small
(i.e., &lt;= 1e-8) are removed with a warning.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int array, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.KBinsDiscretizer.bin_edges_">
<code class="sig-name descname">bin_edges_</code><a class="headerlink" href="#ballet.eng.external.KBinsDiscretizer.bin_edges_" title="Permalink to this definition">¶</a></dt>
<dd><p>The edges of each bin. Contain arrays of varying shapes <code class="docutils literal notranslate"><span class="pre">(n_bins_,</span> <span class="pre">)</span></code>
Ignored features will have empty arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of arrays, shape (n_features, )</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.Binarizer</span></code></dt><dd><p>Class used to bin values as <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code> based on a parameter <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In bin edges for feature <code class="docutils literal notranslate"><span class="pre">i</span></code>, the first and last values are used only for
<code class="docutils literal notranslate"><span class="pre">inverse_transform</span></code>. During transform, bin edges are extended to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">bin_edges_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
</pre></div>
</div>
<p>You can combine <code class="docutils literal notranslate"><span class="pre">KBinsDiscretizer</span></code> with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.compose.ColumnTransformer</span></code> if you only want to preprocess
part of the features.</p>
<p><code class="docutils literal notranslate"><span class="pre">KBinsDiscretizer</span></code> might produce constant features (e.g., when
<code class="docutils literal notranslate"><span class="pre">encode</span> <span class="pre">=</span> <span class="pre">'onehot'</span></code> and certain bins do not contain any data).
These features can be removed with feature selection algorithms
(e.g., <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.feature_selection.VarianceThreshold</span></code>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>    <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">KBinsDiscretizer</span><span class="p">(</span><span class="n">n_bins</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">encode</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;uniform&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">KBinsDiscretizer(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xt</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xt</span>  
<span class="go">array([[ 0., 0., 0., 0.],</span>
<span class="go">       [ 1., 1., 1., 0.],</span>
<span class="go">       [ 2., 2., 2., 1.],</span>
<span class="go">       [ 2., 2., 2., 2.]])</span>
</pre></div>
</div>
<p>Sometimes it may be useful to convert the data back into the original
feature space. The <code class="docutils literal notranslate"><span class="pre">inverse_transform</span></code> function converts the binned
data into the original feature space. Each value will be equal to the mean
of the two bin edges.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">bin_edges_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([-2., -1.,  0.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">Xt</span><span class="p">)</span>
<span class="go">array([[-1.5,  1.5, -3.5, -0.5],</span>
<span class="go">       [-0.5,  2.5, -2.5, -0.5],</span>
<span class="go">       [ 0.5,  3.5, -1.5,  0.5],</span>
<span class="go">       [ 0.5,  3.5, -1.5,  1.5]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.KBinsDiscretizer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_discretization.html#KBinsDiscretizer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KBinsDiscretizer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>numeric array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Data to be discretized.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.KBinsDiscretizer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Xt</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_discretization.html#KBinsDiscretizer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KBinsDiscretizer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform discretized data back to original feature space.</p>
<p>Note that this function does not regenerate the original data
due to discretization rounding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Xt</strong> (<em>numeric array-like</em><em>, </em><em>shape</em><em> (</em><em>n_sample</em><em>, </em><em>n_features</em><em>)</em>) – Transformed data in the binned space.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xinv</strong> – Data in the original feature space.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numeric array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.KBinsDiscretizer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_discretization.html#KBinsDiscretizer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KBinsDiscretizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretize the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>numeric array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Data to be discretized.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – Data in the binned space.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numeric array-like or sparse matrix</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.KNNImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">KNNImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_knn.html#KNNImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KNNImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute._base._BaseImputer</span></code></p>
<p>Imputation for completing missing values using k-Nearest Neighbors.</p>
<p>Each sample’s missing values are imputed using the mean value from
<cite>n_neighbors</cite> nearest neighbors found in the training set. Two samples are
close if the features that neither is missing are close.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.22.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_values</strong> (<em>number</em><em>, </em><em>string</em><em>, </em><em>np.nan</em><em> or </em><em>None</em><em>, </em><em>default=`np.nan`</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to <cite>np.nan</cite>, since <cite>pd.NA</cite> will be converted to <cite>np.nan</cite>.</p></li>
<li><p><strong>n_neighbors</strong> (<em>int</em><em>, </em><em>default=5</em>) – Number of neighboring samples to use for imputation.</p></li>
<li><p><strong>weights</strong> (<em>{'uniform'</em><em>, </em><em>'distance'}</em><em> or </em><em>callable</em><em>, </em><em>default='uniform'</em>) – <p>Weight function used in prediction.  Possible values:</p>
<ul>
<li><p>’uniform’ : uniform weights. All points in each neighborhood are
weighted equally.</p></li>
<li><p>’distance’ : weight points by the inverse of their distance.
in this case, closer neighbors of a query point will have a
greater influence than neighbors which are further away.</p></li>
<li><p>callable : a user-defined function which accepts an
array of distances, and returns an array of the same shape
containing the weights.</p></li>
</ul>
</p></li>
<li><p><strong>metric</strong> (<em>{'nan_euclidean'}</em><em> or </em><em>callable</em><em>, </em><em>default='nan_euclidean'</em>) – <p>Distance metric for searching neighbors. Possible values:</p>
<ul>
<li><p>’nan_euclidean’</p></li>
<li><p>callable : a user-defined function which conforms to the definition
of <code class="docutils literal notranslate"><span class="pre">_pairwise_callable(X,</span> <span class="pre">Y,</span> <span class="pre">metric,</span> <span class="pre">**kwds)</span></code>. The function
accepts two arrays, X and Y, and a <cite>missing_values</cite> keyword in
<cite>kwds</cite> and returns a scalar distance value.</p></li>
</ul>
</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, a copy of X will be created. If False, imputation will
be done in-place whenever possible.</p></li>
<li><p><strong>add_indicator</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, a <a class="reference internal" href="#ballet.eng.external.MissingIndicator" title="ballet.eng.external.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a> transform will stack onto the
output of the imputer’s transform. This allows a predictive estimator
to account for missingness despite imputation. If a feature has no
missing values at fit/train time, the feature won’t appear on the
missing indicator even if there are missing values at transform/test
time.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.KNNImputer.indicator_">
<code class="sig-name descname">indicator_</code><a class="headerlink" href="#ballet.eng.external.KNNImputer.indicator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator used to add binary indicators for missing values.
<code class="docutils literal notranslate"><span class="pre">None</span></code> if add_indicator is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute.MissingIndicator</span></code></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<ul class="simple">
<li><p>Olga Troyanskaya, Michael Cantor, Gavin Sherlock, Pat Brown, Trevor
Hastie, Robert Tibshirani, David Botstein and Russ B. Altman, Missing
value estimation methods for DNA microarrays, BIOINFORMATICS Vol. 17
no. 6, 2001 Pages 520-525.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">KNNImputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imputer</span> <span class="o">=</span> <span class="n">KNNImputer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[1. , 2. , 4. ],</span>
<span class="go">       [3. , 4. , 3. ],</span>
<span class="go">       [5.5, 6. , 5. ],</span>
<span class="go">       [8. , 8. , 7. ]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.KNNImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_knn.html#KNNImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KNNImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the imputer on X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like shape of</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where <cite>n_samples</cite> is the number of samples and
<cite>n_features</cite> is the number of features.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.KNNImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_knn.html#KNNImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.KNNImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute all missing values in X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The imputed dataset. <cite>n_output_features</cite> is the number of features
that is not always missing during <cite>fit</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_output_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.LeaveOneOutEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">LeaveOneOutEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>Leave one out coding for categorical features.</p>
<p>This is very similar to target encoding but excludes the current row’s
target when calculating the mean target for a level to reduce the effect
of outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’  and ‘value’, defaults to ‘value’, which returns the target mean.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’ and ‘value’, defaults to ‘value’, which returns the target mean.</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – adds normal (Gaussian) distribution noise into training data in order to decrease overfitting (testing
data are untouched). Sigma gives the standard deviation (spread or “width”) of the normal distribution.
The optimal value is commonly between 0.05 and 0.6. The default is to not add noise, but that leads
to significantly suboptimal results.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">LeaveOneOutEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets">1</span></dt>
<dd><p>Strategies to encode categorical variables with many categories, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://www.kaggle.com/c/caterpillar-tube-pricing/discussion/15748#143154">https://www.kaggle.com/c/caterpillar-tube-pricing/discussion/15748#143154</a>.</p>
<dl class="py method">
<dt id="ballet.eng.external.LeaveOneOutEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LeaveOneOutEncoder.fit_column_map">
<code class="sig-name descname">fit_column_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">series</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder.fit_column_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder.fit_column_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LeaveOneOutEncoder.fit_leave_one_out">
<code class="sig-name descname">fit_leave_one_out</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder.fit_leave_one_out"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder.fit_leave_one_out" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LeaveOneOutEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LeaveOneOutEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target information (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LeaveOneOutEncoder.transform_leave_one_out">
<code class="sig-name descname">transform_leave_one_out</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/leave_one_out.html#LeaveOneOutEncoder.transform_leave_one_out"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LeaveOneOutEncoder.transform_leave_one_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Leave one out encoding uses a single column of floats to represent the means of the target variables.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.LogTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">LogTransformer</code><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LogTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.LogTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LogTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LogTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LogTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.LogTransformer.needs_refit">
<code class="sig-name descname">needs_refit</code><em class="property"> = False</em><a class="headerlink" href="#ballet.eng.external.LogTransformer.needs_refit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.LogTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">refit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.LogTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id0">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">LogTransformer</code><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="id16">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id16" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="id17">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id17" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="id18">
<code class="sig-name descname">needs_refit</code><em class="property"> = False</em><a class="headerlink" href="#id18" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="id19">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">refit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#LogTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id19" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.MEstimateEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">MEstimateEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">randomized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">m</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/m_estimate.html#MEstimateEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MEstimateEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>M-probability estimate of likelihood.</p>
<p>This is a simplified version of target encoder, which goes under names like m-probability estimate or
additive smoothing with known incidence rates. In comparison to target encoder, m-probability estimate
has only one tunable parameter (<cite>m</cite>), while target encoder has two tunable parameters (<cite>min_samples_leaf</cite>
and <cite>smoothing</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop encoded columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which returns the prior probability.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which returns the prior probability.</p></li>
<li><p><strong>randomized</strong> (<em>bool</em><em>,</em>) – adds normal (Gaussian) distribution noise into training data in order to decrease overfitting (testing data are untouched).</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – standard deviation (spread or “width”) of the normal distribution.</p></li>
<li><p><strong>m</strong> (<em>float</em>) – this is the “m” in the m-probability estimate. Higher value of m results into stronger shrinking.
M is non-negative.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span> <span class="o">&gt;</span> <span class="mf">22.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">MEstimateEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id20"><span class="brackets">1</span></dt>
<dd><p>A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems, equation 7, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://dl.acm.org/citation.cfm?id=507538">https://dl.acm.org/citation.cfm?id=507538</a></p>
<dl class="footnote brackets">
<dt class="label" id="id21"><span class="brackets">2</span></dt>
<dd><p>On estimating probabilities in tree pruning, equation 1, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://link.springer.com/chapter/10.1007/BFb0017010">https://link.springer.com/chapter/10.1007/BFb0017010</a></p>
<dl class="footnote brackets">
<dt class="label" id="id22"><span class="brackets">3</span></dt>
<dd><p>Additive smoothing, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Additive_smoothing#Generalized_to_the_case_of_known_incidence_rates">https://en.wikipedia.org/wiki/Additive_smoothing#Generalized_to_the_case_of_known_incidence_rates</a></p>
<dl class="py method">
<dt id="ballet.eng.external.MEstimateEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/m_estimate.html#MEstimateEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MEstimateEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and binary y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Binary target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MEstimateEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/m_estimate.html#MEstimateEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MEstimateEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MEstimateEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/m_estimate.html#MEstimateEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MEstimateEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<p>When the data are used for model training, it is important to also pass the target in order to apply leave one out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target information (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.MaxAbsScaler">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">MaxAbsScaler</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MaxAbsScaler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Scale each feature by its maximum absolute value.</p>
<p>This estimator scales and translates each feature individually such
that the maximal absolute value of each feature in the
training set will be 1.0. It does not shift/center the data, and
thus does not destroy any sparsity.</p>
<p>This scaler can also be applied to sparse CSR or CSC matrices.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default is True</em>) – Set to False to perform inplace scaling and avoid a copy (if the input
is already a numpy array).</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.MaxAbsScaler.scale_">
<code class="sig-name descname">scale_</code><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.scale_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature relative scaling of the data.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MaxAbsScaler.max_abs_">
<code class="sig-name descname">max_abs_</code><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.max_abs_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature maximum absolute value.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MaxAbsScaler.n_samples_seen_">
<code class="sig-name descname">n_samples_seen_</code><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.n_samples_seen_" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of samples processed by the estimator. Will be reset on
new calls to fit, but increments across <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> calls.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MaxAbsScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">MaxAbsScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span>
<span class="go">MaxAbsScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 0.5, -1. ,  1. ],</span>
<span class="go">       [ 1. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  1. , -0.5]])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">maxabs_scale</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<dl class="py method">
<dt id="ballet.eng.external.MaxAbsScaler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MaxAbsScaler.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximum absolute value to be used for later scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to compute the per-feature minimum and maximum
used for later scaling along the features axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MaxAbsScaler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MaxAbsScaler.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em>) – The data that should be transformed back.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MaxAbsScaler.partial_fit">
<code class="sig-name descname">partial_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MaxAbsScaler.partial_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of max absolute value of X for later scaling.</p>
<p>All of X is processed as a single batch. This is intended for cases
when <a class="reference internal" href="#ballet.eng.external.MaxAbsScaler.fit" title="ballet.eng.external.MaxAbsScaler.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> is not feasible due to very large number of
<cite>n_samples</cite> or because X is read from a continuous stream.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Transformer instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MaxAbsScaler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MaxAbsScaler.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MaxAbsScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em>) – The data that should be scaled.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.MeanCategoricalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">MeanCategoricalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#MeanCategoricalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanCategoricalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseCategoricalTransformer</span></code></p>
<p>The MeanCategoricalEncoder() replaces categories by the mean value of the
target for each category.</p>
<p>For example in the variable colour, if the mean of the target for blue, red
and grey is 0.5, 0.8 and 0.1 respectively, blue is replaced by 0.5, red by 0.8
and grey by 0.1.</p>
<p>The encoder will encode only categorical variables (type ‘object’). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first maps the categories to the numbers for each variable (fit).</p>
<p>The encoder then transforms the categories to the mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.MeanCategoricalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#MeanCategoricalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanCategoricalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the mean value of the target for each category of the variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to be encoded.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em>) – The target.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.MeanCategoricalEncoder.encoder_dict_">
<code class="sig-name descname">encoder_dict_</code><a class="headerlink" href="#ballet.eng.external.MeanCategoricalEncoder.encoder_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {category: target mean} pairs used
to replace categories in every variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MeanCategoricalEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#MeanCategoricalEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanCategoricalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_transformed</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The transformed dataframe.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The un-transformed dataframe, that is, containing the original values
of the categorical variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MeanCategoricalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#MeanCategoricalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanCategoricalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe containing categories replaced by numbers.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.MeanMedianImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">MeanMedianImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">imputation_method</span><span class="o">=</span><span class="default_value">'median'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#MeanMedianImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanMedianImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseImputer</span></code></p>
<p>The MeanMedianImputer() transforms features by replacing missing data by the mean
or median value of the variable.</p>
<p>The MeanMedianImputer() works only with numerical variables.</p>
<p>Users can pass a list of variables to be imputed as argument. Alternatively, the
MeanMedianImputer() will automatically find and select all variables of type numeric.</p>
<p>The imputer first calculates the mean / median values of the variables (fit).</p>
<p>The imputer then replaces the missing data with the estimated mean / median (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imputation_method</strong> (<em>str</em><em>, </em><em>default=median</em>) – Desired method of imputation. Can take ‘mean’ or ‘median’.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables to be imputed. If None, the imputer will select
all variables of type numeric.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.MeanMedianImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#MeanMedianImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanMedianImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the mean or median values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
User can pass the entire dataframe, not just the variables that need imputation.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) – y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.MeanMedianImputer.imputer_dict_">
<code class="sig-name descname">imputer_dict_</code><a class="headerlink" href="#ballet.eng.external.MeanMedianImputer.imputer_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the mean / median values per variable. These
values will be used by the imputer to replace missing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MeanMedianImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#MeanMedianImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MeanMedianImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.MinMaxScaler">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">MinMaxScaler</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MinMaxScaler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MinMaxScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Transform features by scaling each feature to a given range.</p>
<p>This estimator scales and translates each feature individually such
that it is in the given range on the training set, e.g. between
zero and one.</p>
<p>The transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_std</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">X_std</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span>
</pre></div>
</div>
<p>where min, max = feature_range.</p>
<p>This transformation is often used as an alternative to zero mean,
unit variance scaling.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_range</strong> (<em>tuple</em><em> (</em><em>min</em><em>, </em><em>max</em><em>)</em><em>, </em><em>default=</em><em>(</em><em>0</em><em>, </em><em>1</em><em>)</em>) – Desired range of transformed data.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Set to False to perform inplace row normalization and avoid a
copy (if the input is already a numpy array).</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.MinMaxScaler.min_">
<code class="sig-name descname">min_</code><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.min_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature adjustment for minimum. Equivalent to
<code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">-</span> <span class="pre">X.min(axis=0)</span> <span class="pre">*</span> <span class="pre">self.scale_</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MinMaxScaler.scale_">
<code class="sig-name descname">scale_</code><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.scale_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature relative scaling of the data. Equivalent to
<code class="docutils literal notranslate"><span class="pre">(max</span> <span class="pre">-</span> <span class="pre">min)</span> <span class="pre">/</span> <span class="pre">(X.max(axis=0)</span> <span class="pre">-</span> <span class="pre">X.min(axis=0))</span></code></p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MinMaxScaler.data_min_">
<code class="sig-name descname">data_min_</code><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.data_min_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature minimum seen in the data</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>data_min_</em></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MinMaxScaler.data_max_">
<code class="sig-name descname">data_max_</code><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.data_max_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature maximum seen in the data</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>data_max_</em></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MinMaxScaler.data_range_">
<code class="sig-name descname">data_range_</code><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.data_range_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature range <code class="docutils literal notranslate"><span class="pre">(data_max_</span> <span class="pre">-</span> <span class="pre">data_min_)</span></code> seen in the data</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>data_range_</em></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.MinMaxScaler.n_samples_seen_">
<code class="sig-name descname">n_samples_seen_</code><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.n_samples_seen_" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of samples processed by the estimator.
It will be reset on new calls to fit, but increments across
<code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> calls.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">18</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">MinMaxScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">data_max_</span><span class="p">)</span>
<span class="go">[ 1. 18.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[0.   0.  ]</span>
<span class="go"> [0.25 0.25]</span>
<span class="go"> [0.5  0.5 ]</span>
<span class="go"> [1.   1.  ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
<span class="go">[[1.5 0. ]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">minmax_scale</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<dl class="py method">
<dt id="ballet.eng.external.MinMaxScaler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MinMaxScaler.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum and maximum to be used for later scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to compute the per-feature minimum and maximum
used for later scaling along the features axis.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Fitted scaler.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MinMaxScaler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MinMaxScaler.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo the scaling of X according to feature_range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data that will be transformed. It cannot be sparse.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – Transformed data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MinMaxScaler.partial_fit">
<code class="sig-name descname">partial_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MinMaxScaler.partial_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of min and max on X for later scaling.</p>
<p>All of X is processed as a single batch. This is intended for cases
when <a class="reference internal" href="#ballet.eng.external.MinMaxScaler.fit" title="ballet.eng.external.MinMaxScaler.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> is not feasible due to very large number of
<cite>n_samples</cite> or because X is read from a continuous stream.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Transformer instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MinMaxScaler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#MinMaxScaler.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MinMaxScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale features of X according to feature_range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like of shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data that will be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – Transformed data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.MissingIndicator">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">MissingIndicator</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#MissingIndicator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MissingIndicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Binary indicators for missing values.</p>
<p>Note that this component typically should not be used in a vanilla
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code> consisting of transformers and a classifier, but rather
could be added using a <code class="xref py py-class docutils literal notranslate"><span class="pre">FeatureUnion</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnTransformer</span></code>.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_values</strong> (<em>number</em><em>, </em><em>string</em><em>, </em><em>np.nan</em><em> (</em><em>default</em><em>) or </em><em>None</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to <cite>np.nan</cite>, since <cite>pd.NA</cite> will be converted to <cite>np.nan</cite>.</p></li>
<li><p><strong>features</strong> (<em>str</em><em>, </em><em>default=None</em>) – <p>Whether the imputer mask should represent all or a subset of
features.</p>
<ul>
<li><p>If “missing-only” (default), the imputer mask will only represent
features containing missing values during fit time.</p></li>
<li><p>If “all”, the imputer mask will represent all features.</p></li>
</ul>
</p></li>
<li><p><strong>sparse</strong> (<em>boolean</em><em> or </em><em>&quot;auto&quot;</em><em>, </em><em>default=None</em>) – <p>Whether the imputer mask format should be sparse or dense.</p>
<ul>
<li><p>If “auto” (default), the imputer mask will be of same type as
input.</p></li>
<li><p>If True, the imputer mask will be a sparse matrix.</p></li>
<li><p>If False, the imputer mask will be a numpy array.</p></li>
</ul>
</p></li>
<li><p><strong>error_on_new</strong> (<em>boolean</em><em>, </em><em>default=None</em>) – If True (default), transform will raise an error when there are
features with missing values in transform that have no missing values
in fit. This is applicable only when <code class="docutils literal notranslate"><span class="pre">features=&quot;missing-only&quot;</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.MissingIndicator.features_">
<code class="sig-name descname">features_</code><a class="headerlink" href="#ballet.eng.external.MissingIndicator.features_" title="Permalink to this definition">¶</a></dt>
<dd><p>The features indices which will be returned when calling <code class="docutils literal notranslate"><span class="pre">transform</span></code>.
They are computed during <code class="docutils literal notranslate"><span class="pre">fit</span></code>. For <code class="docutils literal notranslate"><span class="pre">features='all'</span></code>, it is
to <code class="docutils literal notranslate"><span class="pre">range(n_features)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, shape (n_missing_features,) or (n_features,)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">MissingIndicator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indicator</span> <span class="o">=</span> <span class="n">MissingIndicator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indicator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>
<span class="go">MissingIndicator()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2_tr</span> <span class="o">=</span> <span class="n">indicator</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X2_tr</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [ True, False],</span>
<span class="go">       [False, False]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.MissingIndicator.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#MissingIndicator.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MissingIndicator.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transformer on X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> is the number of samples and
<code class="docutils literal notranslate"><span class="pre">n_features</span></code> is the number of features.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MissingIndicator.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#MissingIndicator.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MissingIndicator.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate missing values indicator for X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The missing indicator for input data. The data type of <code class="docutils literal notranslate"><span class="pre">Xt</span></code>
will be boolean.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray or sparse matrix}, shape (n_samples, n_features)         or (n_samples, n_features_with_missing)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.MissingIndicator.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#MissingIndicator.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.MissingIndicator.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate missing values indicator for X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The missing indicator for input data. The data type of <code class="docutils literal notranslate"><span class="pre">Xt</span></code>
will be boolean.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{ndarray or sparse matrix}, shape (n_samples, n_features)         or (n_samples, n_features_with_missing)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.Normalizer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">Normalizer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#Normalizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Normalizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Normalize samples individually to unit norm.</p>
<p>Each sample (i.e. each row of the data matrix) with at least one
non zero component is rescaled independently of other samples so
that its norm (l1, l2 or inf) equals one.</p>
<p>This transformer is able to work both with dense numpy arrays and
scipy.sparse matrix (use CSR format if you want to avoid the burden of
a copy / conversion).</p>
<p>Scaling inputs to unit norms is a common operation for text
classification or clustering for instance. For instance the dot
product of two l2-normalized TF-IDF vectors is the cosine similarity
of the vectors and is the base similarity metric for the Vector
Space Model commonly used by the Information Retrieval community.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>norm</strong> (<em>'l1'</em><em>, </em><em>'l2'</em><em>, or </em><em>'max'</em><em>, </em><em>optional</em><em> (</em><em>'l2' by default</em><em>)</em>) – The norm to use to normalize each non zero sample. If norm=’max’
is used, values will be rescaled by the maximum of the absolute
values.</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – set to False to perform inplace row normalization and avoid a
copy (if the input is already a numpy array or a scipy.sparse
CSR matrix).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Normalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">Normalizer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>  <span class="c1"># fit does nothing.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span>
<span class="go">Normalizer()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[0.8, 0.2, 0.4, 0.4],</span>
<span class="go">       [0.1, 0.3, 0.9, 0.3],</span>
<span class="go">       [0.5, 0.7, 0.5, 0.1]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This estimator is stateless (besides constructor parameters), the
fit method does nothing but is useful when used in a pipeline.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">normalize</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt id="ballet.eng.external.Normalizer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#Normalizer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Normalizer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing and return the estimator unchanged</p>
<p>This method is just there to implement the usual API and hence
work in pipelines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.Normalizer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#Normalizer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Normalizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale each non zero row of X to unit norm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to normalize, row by row. scipy.sparse matrices should be
in CSR format to avoid an un-necessary copy.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default: None</em><em>)</em>) – Copy the input X or not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.OneHotCategoricalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OneHotCategoricalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">top_categories</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_last</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OneHotCategoricalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotCategoricalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>One hot encoding consists in replacing the categorical variable by a
combination of binary variables which take value 0 or 1, to indicate if
a certain category is present in an observation.</p>
<p>Each one of the binary variables are also known as dummy variables. For
example, from the categorical variable “Gender” with categories ‘female’
and ‘male’, we can generate the boolean variable “female”, which takes 1
if the person is female or 0 otherwise. We can also generate the variable
male, which takes 1 if the person is “male” and 0 otherwise.</p>
<p>The encoder has the option to generate one dummy variable per category, or
to create dummy variables only for the top n most popular categories, that is,
the categories that are shown by the majority of the observations.</p>
<p>If dummy variables are created for all the categories of a variable, you have
the option to drop one category not to create information redundancy. That is,
encoding into k-1 variables, where k is the number if unique categories.</p>
<p>The encoder will encode only categorical variables (type ‘object’). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode categorical variables (object type).</p>
<p>The encoder first finds the categories to be encoded for each variable (fit).</p>
<p>The encoder then creates one dummy variable per category for each variable
(transform).</p>
<p>Note: new categories in the data to transform, that is, those that did not appear
in the training set, will be ignored (no binary variable will be created for them).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>top_categories</strong> (<em>int</em><em>, </em><em>default=None</em>) – If None, a dummy variable will be created for each category of the variable.
Alternatively, top_categories indicates the number of most frequent categories
to encode. Dummy variables will be created only for those popular categories
and the rest will be ignored. Note that this is equivalent to grouping all the
remaining categories in one group.</p></li>
<li><p><strong>variables</strong> (<em>list</em>) – The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p></li>
<li><p><strong>drop_last</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – Only used if top_categories = None. It indicates whether to create dummy
variables for all the categories (k dummies), or if set to True, it will
ignore the last variable of the list (k-1 dummies).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.OneHotCategoricalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OneHotCategoricalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotCategoricalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the unique categories per variable. If top_categories is indicated,
it will learn the most popular categories. Alternatively, it learns all
unique categories per variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just seleted variables.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em><em>, </em><em>default=None</em>) – Target. It is not needed in this encoded. You can pass y or
None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.OneHotCategoricalEncoder.encoder_dict_">
<code class="sig-name descname">encoder_dict_</code><a class="headerlink" href="#ballet.eng.external.OneHotCategoricalEncoder.encoder_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the categories for which dummy variables
will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OneHotCategoricalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OneHotCategoricalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotCategoricalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the dummy / binary variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to transform.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The shape of the dataframe will be different from the original as it includes the dummy variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.OneHotEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OneHotEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing._encoders._BaseEncoder</span></code></p>
<p>Encode categorical features as a one-hot numeric array.</p>
<p>The input to this transformer should be an array-like of integers or
strings, denoting the values taken on by categorical (discrete) features.
The features are encoded using a one-hot (aka ‘one-of-K’ or ‘dummy’)
encoding scheme. This creates a binary column for each category and
returns a sparse matrix or dense array (depending on the <code class="docutils literal notranslate"><span class="pre">sparse</span></code>
parameter)</p>
<p>By default, the encoder derives the categories based on the unique values
in each feature. Alternatively, you can also specify the <cite>categories</cite>
manually.</p>
<p>This encoding is needed for feeding categorical data to many scikit-learn
estimators, notably linear models and SVMs with the standard kernels.</p>
<p>Note: a one-hot encoding of y labels should use a LabelBinarizer
instead.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>categories</strong> (<em>'auto'</em><em> or </em><em>a list of array-like</em><em>, </em><em>default='auto'</em>) – <p>Categories (unique values) per feature:</p>
<ul>
<li><p>’auto’ : Determine categories automatically from the training data.</p></li>
<li><p>list : <code class="docutils literal notranslate"><span class="pre">categories[i]</span></code> holds the categories expected in the ith
column. The passed categories should not mix strings and numeric
values within a single feature, and should be sorted in case of
numeric values.</p></li>
</ul>
<p>The used categories can be found in the <code class="docutils literal notranslate"><span class="pre">categories_</span></code> attribute.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>drop</strong> (<em>{'first'</em><em>, </em><em>'if_binary'}</em><em> or </em><em>a array-like of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>,             </em><em>default=None</em>) – <p>Specifies a methodology to use to drop one of the categories per
feature. This is useful in situations where perfectly collinear
features cause problems, such as when feeding the resulting data
into a neural network or an unregularized regression.</p>
<p>However, dropping one category breaks the symmetry of the original
representation and can therefore induce a bias in downstream models,
for instance for penalized linear classification or regression models.</p>
<ul>
<li><p>None : retain all features (the default).</p></li>
<li><p>’first’ : drop the first category in each feature. If only one
category is present, the feature will be dropped entirely.</p></li>
<li><p>’if_binary’ : drop the first category in each feature with two
categories. Features with 1 or more than 2 categories are
left intact.</p></li>
<li><p>array : <code class="docutils literal notranslate"><span class="pre">drop[i]</span></code> is the category in feature <code class="docutils literal notranslate"><span class="pre">X[:,</span> <span class="pre">i]</span></code> that
should be dropped.</p></li>
</ul>
</p></li>
<li><p><strong>sparse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Will return sparse matrix if set True else will return an array.</p></li>
<li><p><strong>dtype</strong> (<em>number type</em><em>, </em><em>default=np.float</em>) – Desired dtype of output.</p></li>
<li><p><strong>handle_unknown</strong> (<em>{'error'</em><em>, </em><em>'ignore'}</em><em>, </em><em>default='error'</em>) – Whether to raise an error or ignore if an unknown categorical feature
is present during transform (default is to raise). When this parameter
is set to ‘ignore’ and an unknown category is encountered during
transform, the resulting one-hot encoded columns for this feature
will be all zeros. In the inverse transform, an unknown category
will be denoted as None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.OneHotEncoder.categories_">
<code class="sig-name descname">categories_</code><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.categories_" title="Permalink to this definition">¶</a></dt>
<dd><p>The categories of each feature determined during fitting
(in order of the features in X and corresponding with the output
of <code class="docutils literal notranslate"><span class="pre">transform</span></code>). This includes the category specified in <code class="docutils literal notranslate"><span class="pre">drop</span></code>
(if any).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.OneHotEncoder.drop_idx_">
<code class="sig-name descname">drop_idx_</code><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.drop_idx_" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">drop_idx_[i]</span></code> is the index in <code class="docutils literal notranslate"><span class="pre">categories_[i]</span></code> of the category
to be dropped for each feature.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drop_idx_[i]</span> <span class="pre">=</span> <span class="pre">None</span></code> if no category is to be dropped from the
feature with index <code class="docutils literal notranslate"><span class="pre">i</span></code>, e.g. when <cite>drop=’if_binary’</cite> and the
feature isn’t binary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drop_idx_</span> <span class="pre">=</span> <span class="pre">None</span></code> if all the transformed features will be
retained.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.OrdinalEncoder</span></code></dt><dd><p>Performs an ordinal (integer) encoding of the categorical features.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.feature_extraction.DictVectorizer</span></code></dt><dd><p>Performs a one-hot encoding of dictionary items (also handles string-valued features).</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.feature_extraction.FeatureHasher</span></code></dt><dd><p>Performs an approximate one-hot encoding of dictionary items or strings.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.LabelBinarizer</span></code></dt><dd><p>Binarizes labels in a one-vs-all fashion.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.MultiLabelBinarizer</span></code></dt><dd><p>Transforms between iterable of iterables and a multilabel format, e.g. a (samples x classes) binary matrix indicating the presence of a class label.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Given a dataset with two features, we let the encoder find the unique
values per feature and transform the data to a binary one-hot encoding.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OneHotEncoder</span>
</pre></div>
</div>
<p>One can discard categories not seen during <cite>fit</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">handle_unknown</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">OneHotEncoder(handle_unknown=&#39;ignore&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;Female&#39;, &#39;Male&#39;], dtype=object), array([1, 2, 3], dtype=object)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 0., 1., 0., 0.],</span>
<span class="go">       [0., 1., 0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="go">array([[&#39;Male&#39;, 1],</span>
<span class="go">       [None, 2]], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">([</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">])</span>
<span class="go">array([&#39;gender_Female&#39;, &#39;gender_Male&#39;, &#39;group_1&#39;, &#39;group_2&#39;, &#39;group_3&#39;],</span>
<span class="go">  dtype=object)</span>
</pre></div>
</div>
<p>One can always drop the first column for each feature:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">drop_enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">drop_enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;Female&#39;, &#39;Male&#39;], dtype=object), array([1, 2, 3], dtype=object)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">drop_enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[0., 0., 0.],</span>
<span class="go">       [1., 1., 0.]])</span>
</pre></div>
</div>
<p>Or drop a column for feature only having 2 categories:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">drop_binary_enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;if_binary&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">drop_binary_enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[0., 1., 0., 0.],</span>
<span class="go">       [1., 0., 1., 0.]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.OneHotEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit OneHotEncoder to X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to determine the categories of each feature.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OneHotEncoder.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit OneHotEncoder to X, then transform X.</p>
<p>Equivalent to fit(X).transform(X) but more convenient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to encode.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix if sparse=True else a 2-d array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OneHotEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return feature names for output features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_features</strong> (<em>list of str of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – String names for input features if available. By default,
“x0”, “x1”, … “xn_features” is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>output_feature_names</strong> – Array of feature names.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_output_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OneHotEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<p>In case unknown categories are encountered (all zeros in the
one-hot encoding), <code class="docutils literal notranslate"><span class="pre">None</span></code> is used to represent this category.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_encoded_features</em><em>]</em>) – The transformed data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_tr</strong> – Inverse transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OneHotEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OneHotEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X using one-hot encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to encode.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix if sparse=True else a 2-d array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id23">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OneHotEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id23" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing._encoders._BaseEncoder</span></code></p>
<p>Encode categorical features as a one-hot numeric array.</p>
<p>The input to this transformer should be an array-like of integers or
strings, denoting the values taken on by categorical (discrete) features.
The features are encoded using a one-hot (aka ‘one-of-K’ or ‘dummy’)
encoding scheme. This creates a binary column for each category and
returns a sparse matrix or dense array (depending on the <code class="docutils literal notranslate"><span class="pre">sparse</span></code>
parameter)</p>
<p>By default, the encoder derives the categories based on the unique values
in each feature. Alternatively, you can also specify the <cite>categories</cite>
manually.</p>
<p>This encoding is needed for feeding categorical data to many scikit-learn
estimators, notably linear models and SVMs with the standard kernels.</p>
<p>Note: a one-hot encoding of y labels should use a LabelBinarizer
instead.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>categories</strong> (<em>'auto'</em><em> or </em><em>a list of array-like</em><em>, </em><em>default='auto'</em>) – <p>Categories (unique values) per feature:</p>
<ul>
<li><p>’auto’ : Determine categories automatically from the training data.</p></li>
<li><p>list : <code class="docutils literal notranslate"><span class="pre">categories[i]</span></code> holds the categories expected in the ith
column. The passed categories should not mix strings and numeric
values within a single feature, and should be sorted in case of
numeric values.</p></li>
</ul>
<p>The used categories can be found in the <code class="docutils literal notranslate"><span class="pre">categories_</span></code> attribute.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
</p></li>
<li><p><strong>drop</strong> (<em>{'first'</em><em>, </em><em>'if_binary'}</em><em> or </em><em>a array-like of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em><em>,             </em><em>default=None</em>) – <p>Specifies a methodology to use to drop one of the categories per
feature. This is useful in situations where perfectly collinear
features cause problems, such as when feeding the resulting data
into a neural network or an unregularized regression.</p>
<p>However, dropping one category breaks the symmetry of the original
representation and can therefore induce a bias in downstream models,
for instance for penalized linear classification or regression models.</p>
<ul>
<li><p>None : retain all features (the default).</p></li>
<li><p>’first’ : drop the first category in each feature. If only one
category is present, the feature will be dropped entirely.</p></li>
<li><p>’if_binary’ : drop the first category in each feature with two
categories. Features with 1 or more than 2 categories are
left intact.</p></li>
<li><p>array : <code class="docutils literal notranslate"><span class="pre">drop[i]</span></code> is the category in feature <code class="docutils literal notranslate"><span class="pre">X[:,</span> <span class="pre">i]</span></code> that
should be dropped.</p></li>
</ul>
</p></li>
<li><p><strong>sparse</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Will return sparse matrix if set True else will return an array.</p></li>
<li><p><strong>dtype</strong> (<em>number type</em><em>, </em><em>default=np.float</em>) – Desired dtype of output.</p></li>
<li><p><strong>handle_unknown</strong> (<em>{'error'</em><em>, </em><em>'ignore'}</em><em>, </em><em>default='error'</em>) – Whether to raise an error or ignore if an unknown categorical feature
is present during transform (default is to raise). When this parameter
is set to ‘ignore’ and an unknown category is encountered during
transform, the resulting one-hot encoded columns for this feature
will be all zeros. In the inverse transform, an unknown category
will be denoted as None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="id24">
<code class="sig-name descname">categories_</code><a class="headerlink" href="#id24" title="Permalink to this definition">¶</a></dt>
<dd><p>The categories of each feature determined during fitting
(in order of the features in X and corresponding with the output
of <code class="docutils literal notranslate"><span class="pre">transform</span></code>). This includes the category specified in <code class="docutils literal notranslate"><span class="pre">drop</span></code>
(if any).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="id25">
<code class="sig-name descname">drop_idx_</code><a class="headerlink" href="#id25" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">drop_idx_[i]</span></code> is the index in <code class="docutils literal notranslate"><span class="pre">categories_[i]</span></code> of the category
to be dropped for each feature.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drop_idx_[i]</span> <span class="pre">=</span> <span class="pre">None</span></code> if no category is to be dropped from the
feature with index <code class="docutils literal notranslate"><span class="pre">i</span></code>, e.g. when <cite>drop=’if_binary’</cite> and the
feature isn’t binary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drop_idx_</span> <span class="pre">=</span> <span class="pre">None</span></code> if all the transformed features will be
retained.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.OrdinalEncoder</span></code></dt><dd><p>Performs an ordinal (integer) encoding of the categorical features.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.feature_extraction.DictVectorizer</span></code></dt><dd><p>Performs a one-hot encoding of dictionary items (also handles string-valued features).</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.feature_extraction.FeatureHasher</span></code></dt><dd><p>Performs an approximate one-hot encoding of dictionary items or strings.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.LabelBinarizer</span></code></dt><dd><p>Binarizes labels in a one-vs-all fashion.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.MultiLabelBinarizer</span></code></dt><dd><p>Transforms between iterable of iterables and a multilabel format, e.g. a (samples x classes) binary matrix indicating the presence of a class label.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Given a dataset with two features, we let the encoder find the unique
values per feature and transform the data to a binary one-hot encoding.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OneHotEncoder</span>
</pre></div>
</div>
<p>One can discard categories not seen during <cite>fit</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">handle_unknown</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">OneHotEncoder(handle_unknown=&#39;ignore&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;Female&#39;, &#39;Male&#39;], dtype=object), array([1, 2, 3], dtype=object)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 0., 1., 0., 0.],</span>
<span class="go">       [0., 1., 0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="go">array([[&#39;Male&#39;, 1],</span>
<span class="go">       [None, 2]], dtype=object)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">([</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">])</span>
<span class="go">array([&#39;gender_Female&#39;, &#39;gender_Male&#39;, &#39;group_1&#39;, &#39;group_2&#39;, &#39;group_3&#39;],</span>
<span class="go">  dtype=object)</span>
</pre></div>
</div>
<p>One can always drop the first column for each feature:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">drop_enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">drop_enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;Female&#39;, &#39;Male&#39;], dtype=object), array([1, 2, 3], dtype=object)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">drop_enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[0., 0., 0.],</span>
<span class="go">       [1., 1., 0.]])</span>
</pre></div>
</div>
<p>Or drop a column for feature only having 2 categories:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">drop_binary_enc</span> <span class="o">=</span> <span class="n">OneHotEncoder</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="s1">&#39;if_binary&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">drop_binary_enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[0., 1., 0., 0.],</span>
<span class="go">       [1., 0., 1., 0.]])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="id26">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id26" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit OneHotEncoder to X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to determine the categories of each feature.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id27">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id27" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit OneHotEncoder to X, then transform X.</p>
<p>Equivalent to fit(X).transform(X) but more convenient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to encode.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix if sparse=True else a 2-d array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id28">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id28" title="Permalink to this definition">¶</a></dt>
<dd><p>Return feature names for output features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_features</strong> (<em>list of str of shape</em><em> (</em><em>n_features</em><em>,</em><em>)</em>) – String names for input features if available. By default,
“x0”, “x1”, … “xn_features” is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>output_feature_names</strong> – Array of feature names.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (n_output_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id29">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id29" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<p>In case unknown categories are encountered (all zeros in the
one-hot encoding), <code class="docutils literal notranslate"><span class="pre">None</span></code> is used to represent this category.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_encoded_features</em><em>]</em>) – The transformed data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_tr</strong> – Inverse transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id30">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OneHotEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id30" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X using one-hot encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to encode.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix if sparse=True else a 2-d array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.OrdinalCategoricalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OrdinalCategoricalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encoding_method</span><span class="o">=</span><span class="default_value">'ordered'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OrdinalCategoricalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalCategoricalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseCategoricalTransformer</span></code></p>
<p>The OrdinalCategoricalEncoder() replaces categories by ordinal numbers
(0, 1, 2, 3, etc). The numbers can be ordered based on the mean of the target
per category, or assigned arbitrarily.</p>
<p>Ordered ordinal encoding:  for the variable colour, if the mean of the target
for blue, red and grey is 0.5, 0.8 and 0.1 respectively, blue is replaced by 1,
red by 2 and grey by 0.</p>
<p>Arbitrary ordinal encoding: the numbers will be assigned arbitrarily to the
categories, on a first seen first served basis.</p>
<p>The encoder will encode only categorical variables (type ‘object’). A list
of variables can be passed as an argument. If no variables are passed, the
encoder will find and encode all categorical variables (type ‘object’).</p>
<p>The encoder first maps the categories to the numbers for each variable (fit).</p>
<p>The encoder then transforms the categories to the mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default='ordered'</em>) – <p>Desired method of encoding.</p>
<p>’ordered’: the categories are numbered in ascending order according to
the target mean value per category.</p>
<p>’arbitrary’ : categories are numbered arbitrarily.</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.OrdinalCategoricalEncoder.encoder_dict_">
<code class="sig-name descname">encoder_dict_</code><a class="headerlink" href="#ballet.eng.external.OrdinalCategoricalEncoder.encoder_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {category: ordinal number} pairs for
every variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OrdinalCategoricalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OrdinalCategoricalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalCategoricalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the numbers to be used to replace the categories in each
variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to be
encoded.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em><em>, </em><em>default=None</em>) – The Target. Can be None if encoding_method = ‘arbitrary’.
Otherwise, y needs to be passed when fitting the transformer.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OrdinalCategoricalEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OrdinalCategoricalEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalCategoricalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_transformed</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The transformed dataframe.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The un-transformed dataframe, that is, containing the original values
of the categorical variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OrdinalCategoricalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#OrdinalCategoricalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalCategoricalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe containing categories replaced by numbers.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.OrdinalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OrdinalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing._encoders._BaseEncoder</span></code></p>
<p>Encode categorical features as an integer array.</p>
<p>The input to this transformer should be an array-like of integers or
strings, denoting the values taken on by categorical (discrete) features.
The features are converted to ordinal integers. This results in
a single column of integers (0 to n_categories - 1) per feature.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>categories</strong> (<em>'auto'</em><em> or </em><em>a list of array-like</em><em>, </em><em>default='auto'</em>) – <p>Categories (unique values) per feature:</p>
<ul>
<li><p>’auto’ : Determine categories automatically from the training data.</p></li>
<li><p>list : <code class="docutils literal notranslate"><span class="pre">categories[i]</span></code> holds the categories expected in the ith
column. The passed categories should not mix strings and numeric
values, and should be sorted in case of numeric values.</p></li>
</ul>
<p>The used categories can be found in the <code class="docutils literal notranslate"><span class="pre">categories_</span></code> attribute.</p>
</p></li>
<li><p><strong>dtype</strong> (<em>number type</em><em>, </em><em>default np.float64</em>) – Desired dtype of output.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.OrdinalEncoder.categories_">
<code class="sig-name descname">categories_</code><a class="headerlink" href="#ballet.eng.external.OrdinalEncoder.categories_" title="Permalink to this definition">¶</a></dt>
<dd><p>The categories of each feature determined during fitting
(in order of the features in X and corresponding with the output
of <code class="docutils literal notranslate"><span class="pre">transform</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of arrays</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.OneHotEncoder</span></code></dt><dd><p>Performs a one-hot encoding of categorical features.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.LabelEncoder</span></code></dt><dd><p>Encodes target labels with values between 0 and n_classes-1.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Given a dataset with two features, we let the encoder find the unique
values per feature and transform the data to an ordinal encoding.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OrdinalEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">OrdinalEncoder()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;Female&#39;, &#39;Male&#39;], dtype=object), array([1, 2, 3], dtype=object)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[0., 2.],</span>
<span class="go">       [1., 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[&#39;Male&#39;, 1],</span>
<span class="go">       [&#39;Female&#39;, 2]], dtype=object)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="ballet.eng.external.OrdinalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the OrdinalEncoder to X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to determine the categories of each feature.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OrdinalEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_encoded_features</em><em>]</em>) – The transformed data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_tr</strong> – Inverse transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.OrdinalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OrdinalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X to ordinal codes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to encode.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix or a 2-d array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id31">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OrdinalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id31" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing._encoders._BaseEncoder</span></code></p>
<p>Encode categorical features as an integer array.</p>
<p>The input to this transformer should be an array-like of integers or
strings, denoting the values taken on by categorical (discrete) features.
The features are converted to ordinal integers. This results in
a single column of integers (0 to n_categories - 1) per feature.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>categories</strong> (<em>'auto'</em><em> or </em><em>a list of array-like</em><em>, </em><em>default='auto'</em>) – <p>Categories (unique values) per feature:</p>
<ul>
<li><p>’auto’ : Determine categories automatically from the training data.</p></li>
<li><p>list : <code class="docutils literal notranslate"><span class="pre">categories[i]</span></code> holds the categories expected in the ith
column. The passed categories should not mix strings and numeric
values, and should be sorted in case of numeric values.</p></li>
</ul>
<p>The used categories can be found in the <code class="docutils literal notranslate"><span class="pre">categories_</span></code> attribute.</p>
</p></li>
<li><p><strong>dtype</strong> (<em>number type</em><em>, </em><em>default np.float64</em>) – Desired dtype of output.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="id32">
<code class="sig-name descname">categories_</code><a class="headerlink" href="#id32" title="Permalink to this definition">¶</a></dt>
<dd><p>The categories of each feature determined during fitting
(in order of the features in X and corresponding with the output
of <code class="docutils literal notranslate"><span class="pre">transform</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of arrays</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.OneHotEncoder</span></code></dt><dd><p>Performs a one-hot encoding of categorical features.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.preprocessing.LabelEncoder</span></code></dt><dd><p>Encodes target labels with values between 0 and n_classes-1.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Given a dataset with two features, we let the encoder find the unique
values per feature and transform the data to an ordinal encoding.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OrdinalEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">OrdinalEncoder()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">categories_</span>
<span class="go">[array([&#39;Female&#39;, &#39;Male&#39;], dtype=object), array([1, 2, 3], dtype=object)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="s1">&#39;Female&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Male&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[0., 2.],</span>
<span class="go">       [1., 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="go">array([[&#39;Male&#39;, 1],</span>
<span class="go">       [&#39;Female&#39;, 2]], dtype=object)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="id33">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id33" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the OrdinalEncoder to X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to determine the categories of each feature.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored. This parameter exists only for compatibility with
<code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.pipeline.Pipeline</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id34">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id34" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_encoded_features</em><em>]</em>) – The transformed data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_tr</strong> – Inverse transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id35">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_encoders.html#OrdinalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id35" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform X to ordinal codes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to encode.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_out</strong> – Transformed input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix or a 2-d array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.OutlierTrimmer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">OutlierTrimmer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distribution</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">tail</span><span class="o">=</span><span class="default_value">'right'</span></em>, <em class="sig-param"><span class="n">fold</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">missing_values</span><span class="o">=</span><span class="default_value">'raise'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#OutlierTrimmer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OutlierTrimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.outlier_removers.Winsorizer</span></code></p>
<p>The OutlierTrimmer() removes observations with outliers from the dataset.</p>
<p>It works only with numerical variables. A list of variables can be indicated.
Alternatively, the OutlierTrimmer() will select all numerical variables.</p>
<p>The OutlierTrimmer() first calculates the maximum and /or minimum values
beyond which a value will be considered an outlier, and thus removed.</p>
<p>Limits are determined using 1) a Gaussian approximation, 2) the inter-quantile
range proximity rule or 3) percentiles.</p>
<p>Gaussian limits:</p>
<blockquote>
<div><p>right tail: mean + 3* std</p>
<p>left tail: mean - 3* std</p>
</div></blockquote>
<p>IQR limits:</p>
<blockquote>
<div><p>right tail: 75th quantile + 3* IQR</p>
<p>left tail:  25th quantile - 3* IQR</p>
</div></blockquote>
<p>where IQR is the inter-quartile range: 75th quantile - 25th quantile.</p>
<p>percentiles or quantiles:</p>
<blockquote>
<div><p>right tail: 95th percentile</p>
<p>left tail:  5th percentile</p>
</div></blockquote>
<p>You can select how far out to allow the maximum or minimum values with the
parameter ‘fold’.</p>
<p>If distribution=’gaussian’ fold gives the value to multiply the std.</p>
<p>If distribution=’skewed’ fold is the value to multiply the IQR.</p>
<p>If distribution=’quantile’, fold is the percentile on each tail that should
be censored. For example, if fold=0.05, the limits will be the 5th and 95th
percentiles. If fold=0.1, the limits will be the 10th and 90th percentiles.</p>
<p>The transformer first finds the values at one or both tails of the distributions
(fit).</p>
<p>The transformer then removes observations with outliers from the dataframe
(transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distribution</strong> (<em>str</em><em>, </em><em>default=gaussian</em>) – <p>Desired distribution. Can take ‘gaussian’, ‘skewed’ or ‘quantiles’.</p>
<p>gaussian: the transformer will find the maximum and / or minimum values to
cap the variables using the Gaussian approximation.</p>
<p>skewed: the transformer will find the boundaries using the IQR proximity rule.</p>
<p>quantiles: the limits are given by the percentiles.</p>
</p></li>
<li><p><strong>tail</strong> (<em>str</em><em>, </em><em>default=right</em>) – Whether to cap outliers on the right, left or both tails of the distribution.
Can take ‘left’, ‘right’ or ‘both’.</p></li>
<li><p><strong>fold</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>default=3</em>) – <p>How far out to to place the capping values. The number that will multiply
the std or IQR to calculate the capping values. Recommended values, 2
or 3 for the gaussian approximation, or 1.5 or 3 for the IQR proximity
rule.</p>
<p>If distribution=’quantile’, then ‘fold’ indicates the percentile. So if
fold=0.05, the limits will be the 95th and 5th percentiles.
Note: Outliers will be removed up to a maximum of the 20th percentiles on both
sides. Thus, when distribution=’quantile’, then ‘fold’ takes values between 0
and 0.20.</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables for which the outliers will be capped. If None,
the transformer will find and select all numerical variables.</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='raise'</em>) – Indicates if missing values should be ignored or raised. Sometimes we want to remove
outliers in the raw, original data, sometimes, we may want to remove outliers in the
already pre-transformed data. If missing_values=’ignore’, the transformer will ignore
missing data when learning the capping parameters or transforming the data. If
missing_values=’raise’ the transformer will return an error if the training or other
datasets contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.OutlierTrimmer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#OutlierTrimmer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.OutlierTrimmer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes observations with outliers from the dataframe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe without outlier observations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.PolynomialEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">PolynomialEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/polynomial.html#PolynomialEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Polynomial contrast coding for the encoding of categorical features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has unknown categories.  This can cause
unexpected changes in dimension in some cases.</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has nan values.  This can cause
unexpected changes in dimension in some cases.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">PolynomialEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 21 columns):</span>
<span class="go">intercept    506 non-null int64</span>
<span class="go">CRIM         506 non-null float64</span>
<span class="go">ZN           506 non-null float64</span>
<span class="go">INDUS        506 non-null float64</span>
<span class="go">CHAS_0       506 non-null float64</span>
<span class="go">NOX          506 non-null float64</span>
<span class="go">RM           506 non-null float64</span>
<span class="go">AGE          506 non-null float64</span>
<span class="go">DIS          506 non-null float64</span>
<span class="go">RAD_0        506 non-null float64</span>
<span class="go">RAD_1        506 non-null float64</span>
<span class="go">RAD_2        506 non-null float64</span>
<span class="go">RAD_3        506 non-null float64</span>
<span class="go">RAD_4        506 non-null float64</span>
<span class="go">RAD_5        506 non-null float64</span>
<span class="go">RAD_6        506 non-null float64</span>
<span class="go">RAD_7        506 non-null float64</span>
<span class="go">TAX          506 non-null float64</span>
<span class="go">PTRATIO      506 non-null float64</span>
<span class="go">B            506 non-null float64</span>
<span class="go">LSTAT        506 non-null float64</span>
<span class="go">dtypes: float64(20), int64(1)</span>
<span class="go">memory usage: 83.1 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id36"><span class="brackets">1</span></dt>
<dd><p>Contrast Coding Systems for Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/</a></p>
<dl class="footnote brackets">
<dt class="label" id="id37"><span class="brackets">2</span></dt>
<dd><p>Gregory Carey (2003). Coding Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf">http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf</a></p>
<dl class="py method">
<dt id="ballet.eng.external.PolynomialEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/polynomial.html#PolynomialEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PolynomialEncoder.fit_polynomial_coding">
<em class="property">static </em><code class="sig-name descname">fit_polynomial_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">col</span></em>, <em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="n">handle_missing</span></em>, <em class="sig-param"><span class="n">handle_unknown</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/polynomial.html#PolynomialEncoder.fit_polynomial_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialEncoder.fit_polynomial_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PolynomialEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/polynomial.html#PolynomialEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PolynomialEncoder.polynomial_coding">
<em class="property">static </em><code class="sig-name descname">polynomial_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">mapping</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/polynomial.html#PolynomialEncoder.polynomial_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialEncoder.polynomial_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PolynomialEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/polynomial.html#PolynomialEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.PolynomialFeatures">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">PolynomialFeatures</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PolynomialFeatures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Generate polynomial and interaction features.</p>
<p>Generate a new feature matrix consisting of all polynomial combinations
of the features with degree less than or equal to the specified degree.
For example, if an input sample is two dimensional and of the form
[a, b], the degree-2 polynomial features are [1, a, b, a^2, ab, b^2].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>degree</strong> (<em>integer</em>) – The degree of the polynomial features. Default = 2.</p></li>
<li><p><strong>interaction_only</strong> (<em>boolean</em><em>, </em><em>default = False</em>) – If true, only interaction features are produced: features that are
products of at most <code class="docutils literal notranslate"><span class="pre">degree</span></code> <em>distinct</em> input features (so not
<code class="docutils literal notranslate"><span class="pre">x[1]</span> <span class="pre">**</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">x[0]</span> <span class="pre">*</span> <span class="pre">x[2]</span> <span class="pre">**</span> <span class="pre">3</span></code>, etc.).</p></li>
<li><p><strong>include_bias</strong> (<em>boolean</em>) – If True (default), then include a bias column, the feature in which
all polynomial powers are zero (i.e. a column of ones - acts as an
intercept term in a linear model).</p></li>
<li><p><strong>order</strong> (<em>str in {'C'</em><em>, </em><em>'F'}</em><em>, </em><em>default 'C'</em>) – <p>Order of output array in the dense case. ‘F’ order is faster to
compute, but may slow down subsequent estimators.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.</span></p>
</div>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  1.,  0.,  0.,  1.],</span>
<span class="go">       [ 1.,  2.,  3.,  4.,  6.,  9.],</span>
<span class="go">       [ 1.,  4.,  5., 16., 20., 25.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span> <span class="o">=</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">interaction_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poly</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  1.,  0.],</span>
<span class="go">       [ 1.,  2.,  3.,  6.],</span>
<span class="go">       [ 1.,  4.,  5., 20.]])</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="ballet.eng.external.PolynomialFeatures.powers_">
<code class="sig-name descname">powers_</code><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures.powers_" title="Permalink to this definition">¶</a></dt>
<dd><p>powers_[i, j] is the exponent of the jth input in the ith output.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array, shape (n_output_features, n_input_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.PolynomialFeatures.n_input_features_">
<code class="sig-name descname">n_input_features_</code><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures.n_input_features_" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of input features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.PolynomialFeatures.n_output_features_">
<code class="sig-name descname">n_output_features_</code><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures.n_output_features_" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of polynomial output features. The number of output
features is computed by iterating over all suitably sized combinations
of input features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Be aware that the number of features in the output array scales
polynomially in the number of features of the input array, and
exponentially in the degree. High degrees can cause overfitting.</p>
<p>See <span class="xref std std-ref">examples/linear_model/plot_polynomial_interpolation.py</span></p>
<dl class="py method">
<dt id="ballet.eng.external.PolynomialFeatures.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PolynomialFeatures.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute number of output features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PolynomialFeatures.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_features</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PolynomialFeatures.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return feature names for output features</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_features</strong> (<em>list of string</em><em>, </em><em>length n_features</em><em>, </em><em>optional</em>) – String names for input features if available. By default,
“x0”, “x1”, … “xn_features” is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>output_feature_names</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of string, length n_output_features</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id38">
<em class="property">property </em><code class="sig-name descname">powers_</code><a class="headerlink" href="#id38" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PolynomialFeatures.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PolynomialFeatures.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PolynomialFeatures.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform data to polynomial features</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em> or </em><em>CSR/CSC sparse matrix</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – <p>The data to transform, row by row.</p>
<p>Prefer CSR over CSC for sparse input (for speed), but CSC is
required if the degree is 4 or higher. If the degree is less than
4 and the input format is CSC, it will be converted to CSR, have
its polynomial features generated, then converted back to CSC.</p>
<p>If the degree is 2 or 3, the method described in “Leveraging
Sparsity to Speed Up Polynomial Feature Expansions of CSR Matrices
Using K-Simplex Numbers” by Andrew Nystrom and John Hughes is
used, which is much faster than the method used on CSC input. For
this reason, a CSC input will be converted to CSR, and the output
will be converted back to CSC prior to being returned, hence the
preference of CSR.</p>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>XP</strong> – The matrix of features, where NP is the number of polynomial
features generated from the combination of inputs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray or CSR/CSC sparse matrix, shape [n_samples, NP]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.PowerTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">PowerTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PowerTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Apply a power transform featurewise to make data more Gaussian-like.</p>
<p>Power transforms are a family of parametric, monotonic transformations
that are applied to make data more Gaussian-like. This is useful for
modeling issues related to heteroscedasticity (non-constant variance),
or other situations where normality is desired.</p>
<p>Currently, PowerTransformer supports the Box-Cox transform and the
Yeo-Johnson transform. The optimal parameter for stabilizing variance and
minimizing skewness is estimated through maximum likelihood.</p>
<p>Box-Cox requires input data to be strictly positive, while Yeo-Johnson
supports both positive or negative data.</p>
<p>By default, zero-mean, unit-variance normalization is applied to the
transformed data.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>(</em><em>default='yeo-johnson'</em><em>)</em>) – <p>The power transform method. Available methods are:</p>
<ul>
<li><p>’yeo-johnson’ <a href="#id62"><span class="problematic" id="id39">[1]_</span></a>, works with positive and negative values</p></li>
<li><p>’box-cox’ <a href="#id63"><span class="problematic" id="id40">[2]_</span></a>, only works with strictly positive values</p></li>
</ul>
</p></li>
<li><p><strong>standardize</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – Set to True to apply zero-mean, unit-variance normalization to the
transformed output.</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – Set to False to perform inplace computation during transformation.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.PowerTransformer.lambdas_">
<code class="sig-name descname">lambdas_</code><a class="headerlink" href="#ballet.eng.external.PowerTransformer.lambdas_" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters of the power transformation for the selected features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of float, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PowerTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="n">PowerTransformer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">PowerTransformer()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">lambdas_</span><span class="p">)</span>
<span class="go">[ 1.386... -3.100...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[-1.316... -0.707...]</span>
<span class="go"> [ 0.209... -0.707...]</span>
<span class="go"> [ 1.106...  1.414...]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">power_transform</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
<dt><a class="reference internal" href="#ballet.eng.external.QuantileTransformer" title="ballet.eng.external.QuantileTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantileTransformer</span></code></a></dt><dd><p>Maps data to a standard normal distribution with the parameter <cite>output_distribution=’normal’</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in <code class="docutils literal notranslate"><span class="pre">fit</span></code>, and maintained
in <code class="docutils literal notranslate"><span class="pre">transform</span></code>.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id41"><span class="brackets">1</span></dt>
<dd><p>I.K. Yeo and R.A. Johnson, “A new family of power transformations to
improve normality or symmetry.” Biometrika, 87(4), pp.954-959,
(2000).</p>
</dd>
<dt class="label" id="id42"><span class="brackets">2</span></dt>
<dd><p>G.E.P. Box and D.R. Cox, “An Analysis of Transformations”, Journal
of the Royal Statistical Society B, 26, 211-252 (1964).</p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.PowerTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PowerTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the optimal parameter lambda for each feature.</p>
<p>The optimal lambda parameter for minimizing skewness is estimated on
each feature independently using maximum likelihood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to estimate the optimal transformation parameters.</p></li>
<li><p><strong>y</strong> (<em>Ignored</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PowerTransformer.fit_transform">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PowerTransformer.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix</em><em>, </em><em>dataframe} of shape</em><em>                 (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
<li><p><strong>y</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Target values.</p></li>
<li><p><strong>**fit_params</strong> (<em>dict</em>) – Additional fit parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_new</strong> – Transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray array of shape (n_samples, n_features_new)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PowerTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PowerTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the inverse power transformation using the fitted lambdas.</p>
<p>The inverse of the Box-Cox transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">lambda_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">X_trans</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_trans</span> <span class="o">*</span> <span class="n">lambda_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_</span><span class="p">)</span>
</pre></div>
</div>
<p>The inverse of the Yeo-Johnson transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">X_trans</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">elif</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_trans</span> <span class="o">*</span> <span class="n">lambda_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">elif</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lambda_</span><span class="p">)</span> <span class="o">*</span> <span class="n">X_trans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lambda_</span><span class="p">))</span>
<span class="k">elif</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X_trans</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The transformed data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The original data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.PowerTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.PowerTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the power transform to each feature using the fitted lambdas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data to be transformed using a power transformation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_trans</strong> – The transformed data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="id43">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">PowerTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id43" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Apply a power transform featurewise to make data more Gaussian-like.</p>
<p>Power transforms are a family of parametric, monotonic transformations
that are applied to make data more Gaussian-like. This is useful for
modeling issues related to heteroscedasticity (non-constant variance),
or other situations where normality is desired.</p>
<p>Currently, PowerTransformer supports the Box-Cox transform and the
Yeo-Johnson transform. The optimal parameter for stabilizing variance and
minimizing skewness is estimated through maximum likelihood.</p>
<p>Box-Cox requires input data to be strictly positive, while Yeo-Johnson
supports both positive or negative data.</p>
<p>By default, zero-mean, unit-variance normalization is applied to the
transformed data.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>(</em><em>default='yeo-johnson'</em><em>)</em>) – <p>The power transform method. Available methods are:</p>
<ul>
<li><p>’yeo-johnson’ <a href="#id64"><span class="problematic" id="id44">[1]_</span></a>, works with positive and negative values</p></li>
<li><p>’box-cox’ <a href="#id65"><span class="problematic" id="id45">[2]_</span></a>, only works with strictly positive values</p></li>
</ul>
</p></li>
<li><p><strong>standardize</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – Set to True to apply zero-mean, unit-variance normalization to the
transformed output.</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – Set to False to perform inplace computation during transformation.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="id46">
<code class="sig-name descname">lambdas_</code><a class="headerlink" href="#id46" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters of the power transformation for the selected features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of float, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PowerTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="n">PowerTransformer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">PowerTransformer()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">lambdas_</span><span class="p">)</span>
<span class="go">[ 1.386... -3.100...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[-1.316... -0.707...]</span>
<span class="go"> [ 0.209... -0.707...]</span>
<span class="go"> [ 1.106...  1.414...]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">power_transform</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
<dt><a class="reference internal" href="#ballet.eng.external.QuantileTransformer" title="ballet.eng.external.QuantileTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantileTransformer</span></code></a></dt><dd><p>Maps data to a standard normal distribution with the parameter <cite>output_distribution=’normal’</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in <code class="docutils literal notranslate"><span class="pre">fit</span></code>, and maintained
in <code class="docutils literal notranslate"><span class="pre">transform</span></code>.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id47"><span class="brackets">1</span></dt>
<dd><p>I.K. Yeo and R.A. Johnson, “A new family of power transformations to
improve normality or symmetry.” Biometrika, 87(4), pp.954-959,
(2000).</p>
</dd>
<dt class="label" id="id48"><span class="brackets">2</span></dt>
<dd><p>G.E.P. Box and D.R. Cox, “An Analysis of Transformations”, Journal
of the Royal Statistical Society B, 26, 211-252 (1964).</p>
</dd>
</dl>
<dl class="py method">
<dt id="id49">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id49" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the optimal parameter lambda for each feature.</p>
<p>The optimal lambda parameter for minimizing skewness is estimated on
each feature independently using maximum likelihood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to estimate the optimal transformation parameters.</p></li>
<li><p><strong>y</strong> (<em>Ignored</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id50">
<code class="sig-name descname">fit_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.fit_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id50" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix</em><em>, </em><em>dataframe} of shape</em><em>                 (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – </p></li>
<li><p><strong>y</strong> (<em>ndarray of shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>default=None</em>) – Target values.</p></li>
<li><p><strong>**fit_params</strong> (<em>dict</em>) – Additional fit parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_new</strong> – Transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray array of shape (n_samples, n_features_new)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id51">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id51" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the inverse power transformation using the fitted lambdas.</p>
<p>The inverse of the Box-Cox transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">lambda_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">X_trans</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_trans</span> <span class="o">*</span> <span class="n">lambda_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_</span><span class="p">)</span>
</pre></div>
</div>
<p>The inverse of the Yeo-Johnson transformation is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">X_trans</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">elif</span> <span class="n">X</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_trans</span> <span class="o">*</span> <span class="n">lambda_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">lambda_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="k">elif</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lambda_</span><span class="p">)</span> <span class="o">*</span> <span class="n">X_trans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lambda_</span><span class="p">))</span>
<span class="k">elif</span> <span class="n">X</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lambda_</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X_trans</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The transformed data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The original data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="id52">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#PowerTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id52" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the power transform to each feature using the fitted lambdas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data to be transformed using a power transformation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_trans</strong> – The transformed data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.QuantileTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">QuantileTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#QuantileTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.QuantileTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Transform features using quantiles information.</p>
<p>This method transforms the features to follow a uniform or a normal
distribution. Therefore, for a given feature, this transformation tends
to spread out the most frequent values. It also reduces the impact of
(marginal) outliers: this is therefore a robust preprocessing scheme.</p>
<p>The transformation is applied on each feature independently. First an
estimate of the cumulative distribution function of a feature is
used to map the original values to a uniform distribution. The obtained
values are then mapped to the desired output distribution using the
associated quantile function. Features values of new/unseen data that fall
below or above the fitted range will be mapped to the bounds of the output
distribution. Note that this transform is non-linear. It may distort linear
correlations between variables measured at the same scale but renders
variables measured at different scales more directly comparable.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_quantiles</strong> (<em>int</em><em>, </em><em>optional</em><em> (</em><em>default=1000</em><em> or </em><em>n_samples</em><em>)</em>) – Number of quantiles to be computed. It corresponds to the number
of landmarks used to discretize the cumulative distribution function.
If n_quantiles is larger than the number of samples, n_quantiles is set
to the number of samples as a larger number of quantiles does not give
a better approximation of the cumulative distribution function
estimator.</p></li>
<li><p><strong>output_distribution</strong> (<em>str</em><em>, </em><em>optional</em><em> (</em><em>default='uniform'</em><em>)</em>) – Marginal distribution for the transformed data. The choices are
‘uniform’ (default) or ‘normal’.</p></li>
<li><p><strong>ignore_implicit_zeros</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – Only applies to sparse matrices. If True, the sparse entries of the
matrix are discarded to compute the quantile statistics. If False,
these entries are treated as zeros.</p></li>
<li><p><strong>subsample</strong> (<em>int</em><em>, </em><em>optional</em><em> (</em><em>default=1e5</em><em>)</em>) – Maximum number of samples used to estimate the quantiles for
computational efficiency. Note that the subsampling procedure may
differ for value-identical sparse and dense matrices.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Determines random number generation for subsampling and smoothing
noise.
Please see <code class="docutils literal notranslate"><span class="pre">subsample</span></code> for more details.
Pass an int for reproducible results across multiple function calls.
See <span class="xref std std-term">Glossary</span></p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=True</em><em>)</em>) – Set to False to perform inplace transformation and avoid a copy (if the
input is already a numpy array).</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.QuantileTransformer.n_quantiles_">
<code class="sig-name descname">n_quantiles_</code><a class="headerlink" href="#ballet.eng.external.QuantileTransformer.n_quantiles_" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual number of quantiles used to discretize the cumulative
distribution function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>integer</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.QuantileTransformer.quantiles_">
<code class="sig-name descname">quantiles_</code><a class="headerlink" href="#ballet.eng.external.QuantileTransformer.quantiles_" title="Permalink to this definition">¶</a></dt>
<dd><p>The values corresponding the quantiles of reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, shape (n_quantiles, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.QuantileTransformer.references_">
<code class="sig-name descname">references_</code><a class="headerlink" href="#ballet.eng.external.QuantileTransformer.references_" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantiles of references.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, shape(n_quantiles, )</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">QuantileTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qt</span> <span class="o">=</span> <span class="n">QuantileTransformer</span><span class="p">(</span><span class="n">n_quantiles</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qt</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([...])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">quantile_transform</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
<dt><a class="reference internal" href="#id43" title="ballet.eng.external.PowerTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerTransformer</span></code></a></dt><dd><p>Perform mapping to a normal distribution using a power transform.</p>
</dd>
<dt><a class="reference internal" href="#ballet.eng.external.StandardScaler" title="ballet.eng.external.StandardScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardScaler</span></code></a></dt><dd><p>Perform standardization that is faster, but less robust to outliers.</p>
</dd>
<dt><a class="reference internal" href="#ballet.eng.external.RobustScaler" title="ballet.eng.external.RobustScaler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobustScaler</span></code></a></dt><dd><p>Perform robust standardization that removes the influence of outliers but does not put outliers and inliers on the same scale.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<dl class="py method">
<dt id="ballet.eng.external.QuantileTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#QuantileTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.QuantileTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the quantiles used for transforming.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>ndarray</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.QuantileTransformer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#QuantileTransformer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.QuantileTransformer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Back-projection to the original space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>ndarray</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The projected data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray or sparse matrix, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.QuantileTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#QuantileTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.QuantileTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature-wise transformation of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>ndarray</em><em> or </em><em>sparse matrix</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The data used to scale along the features axis. If a sparse
matrix is provided, it will be converted into a sparse
<code class="docutils literal notranslate"><span class="pre">csc_matrix</span></code>. Additionally, the sparse matrix needs to be
nonnegative if <cite>ignore_implicit_zeros</cite> is False.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Xt</strong> – The projected data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray or sparse matrix, shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.RandomSampleImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">RandomSampleImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">'general'</span></em>, <em class="sig-param"><span class="n">seeding_method</span><span class="o">=</span><span class="default_value">'add'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#RandomSampleImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RandomSampleImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>The RandomSampleImputer() replaces missing data in each feature with a random
sample extracted from the variables in the training set.
The RandomSampleImputer() works with both numerical and categorical variables.
Note: random samples will vary from execution to execution. This may affect
the results of your work. Remember to set a seed before running the
RandomSampleImputer().</p>
<p>There are 2 ways in which the seed can be set with the RandomSampleImputer():
If seed = ‘general’ then the random_state can be either None or an integer.
The seed will be used as the random_state and all observations will be
imputed in one go. This is equivalent to pandas.sample(n, random_state=seed).</p>
<p>If seed = ‘observation’, then the random_state should be a variable name
or a list of variable names. The seed will be calculated, observation per
observation, either by adding or multiplying the seeding variable values for that
observation, and passed to the random_state. Thus, a value will be extracted using
that seed, and used to replace that particular observation. This is the equivalent
of pandas.sample(1, random_state=var1+var2) if the ‘seeding_method’ is set to ‘add’
or pandas.sample(1, random_state=var1*var2) if the ‘seeding_method’ is set to
‘multiply’.</p>
<p>For more details on why this functionality is important refer to the course
Feature Engineering for Machine Learning in Udemy:
<a class="reference external" href="https://www.udemy.com/feature-engineering-for-machine-learning/">https://www.udemy.com/feature-engineering-for-machine-learning/</a></p>
<p>Note, if the variables indicated in the random_state list are not numerical
the imputer will return an error. Note also that the variables indicated as seed
should not contain missing values.</p>
<p>This estimator stores a copy of the training set when the fit() method is
called. Therefore, the object can become quite heavy. Also, it may not be GDPR
compliant if your training data set contains Personal Information. Please check
if this behaviour is allowed within your organisation.
The imputer replaces missing data with a random sample from the training set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>str</em><em> or </em><em>list</em><em>, </em><em>default=None</em>) – The random_state can take an integer to set the seed when extracting the
random samples. Alternatively, it can take a variable name or a list of
variables, which values will be used to determine the seed observation per
observation.</p></li>
<li><p><strong>seed</strong> (<em>str</em><em>, </em><em>default='general'</em>) – <p>Indicates whether the seed should be set for each observation with missing
values, or if one seed should be used to impute all variables in one go.</p>
<p>general: one seed will be used to impute the entire dataframe. This is
equivalent to setting the seed in pandas.sample(random_state).</p>
<p>observation: the seed will be set for each observation using the values
of the variables indicated in the random_state for that particular
observation.</p>
</p></li>
<li><p><strong>seeding_method</strong> (<em>str</em><em>, </em><em>default='add'</em>) – If more than one variable are indicated to seed the random sampling per
observation, you can choose to combine those values as an addition or a
multiplication. Can take the values ‘add’ or ‘multiply’.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables to be imputed. If None, the imputer will select
all variables in the train set.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.RandomSampleImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#RandomSampleImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RandomSampleImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of the variables to impute in the training dataframe from
which it will randomly extract the values to fill the missing data
during transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just he variables to impute.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.RandomSampleImputer.X_">
<code class="sig-name descname">X_</code><a class="headerlink" href="#ballet.eng.external.RandomSampleImputer.X_" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of the training dataframe from which to extract the random samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dataframe.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.RandomSampleImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/missing_data_imputers.html#RandomSampleImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RandomSampleImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces missing data with random values taken from the train set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The dataframe to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe without missing values in the transformed variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.RareLabelCategoricalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">RareLabelCategoricalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">n_categories</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">max_n_categories</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">replace_with</span><span class="o">=</span><span class="default_value">'Rare'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#RareLabelCategoricalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RareLabelCategoricalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>The RareLabelCategoricalEncoder() groups rare / infrequent categories in
a new category called “Rare”, or any other name entered by the user.</p>
<p>For example in the variable colour, if the percentage of observations
for the categories magenta, cyan and burgundy are &lt; 5 %, all those
categories will be replaced by the new label “Rare”.</p>
<p>Note, infrequent labels can also be grouped under a user defined name, for
example ‘Other’. The name to replace infrequent categories is defined
with the parameter replace_with.</p>
<p>The encoder will encode only categorical variables (type ‘object’). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first finds the frequent labels for each variable (fit).</p>
<p>The encoder then groups the infrequent labels under the new label ‘Rare’
or by another user defined string (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>default=0.05</em>) – the minimum frequency a label should have to be considered frequent.
Categories with frequencies lower than tol will be grouped.</p></li>
<li><p><strong>n_categories</strong> (<em>int</em><em>, </em><em>default=10</em>) – the minimum number of categories a variable should have for the encoder
to find frequent labels. If the variable contains less categories, all
of them will be considered frequent.</p></li>
<li><p><strong>max_n_categories</strong> (<em>int</em><em>, </em><em>default=None</em>) – the maximum number of categories that should be considered frequent.
If None, all categories with frequency above the tolerance (tol) will be
considered.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p></li>
<li><p><strong>replace_with</strong> (<em>string</em><em>, </em><em>default='Rare'</em>) – The category name that will be used to replace infrequent categories.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.RareLabelCategoricalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#RareLabelCategoricalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RareLabelCategoricalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the frequent categories for each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just selected variables</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not required. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.RareLabelCategoricalEncoder.encoder_dict_">
<code class="sig-name descname">encoder_dict_</code><a class="headerlink" href="#ballet.eng.external.RareLabelCategoricalEncoder.encoder_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the frequent categories (that will be kept)
for each variable. Categories not present in this list will be replaced
by ‘Rare’ or by the user defined value.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.RareLabelCategoricalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#RareLabelCategoricalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RareLabelCategoricalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Groups rare labels under separate group ‘Rare’ or any other name provided
by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe where rare categories have been grouped.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.ReciprocalTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">ReciprocalTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#ReciprocalTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReciprocalTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The ReciprocalTransformer() applies the reciprocal transformation 1 / x
to numerical variables.</p>
<p>The ReciprocalTransformer() only works with numerical variables with non-zero
values. If a variable contains the value 0, the transformer will raise an error.</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.ReciprocalTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#ReciprocalTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReciprocalTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to transform.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.ReciprocalTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#ReciprocalTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReciprocalTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the reciprocal 1 / x transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to transform.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe with reciprocally transformed variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.ReversibleImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">ReversibleImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y_only</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#ReversibleImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReversibleImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.ReversibleImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#ReversibleImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReversibleImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.ReversibleImputer.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#ReversibleImputer.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReversibleImputer.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.ReversibleImputer.needs_refit">
<code class="sig-name descname">needs_refit</code><em class="property"> = True</em><a class="headerlink" href="#ballet.eng.external.ReversibleImputer.needs_refit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.ReversibleImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">refit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/preprocessing.html#ReversibleImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.ReversibleImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.RobustScaler">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">RobustScaler</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#RobustScaler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RobustScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Scale features using statistics that are robust to outliers.</p>
<p>This Scaler removes the median and scales the data according to
the quantile range (defaults to IQR: Interquartile Range).
The IQR is the range between the 1st quartile (25th quantile)
and the 3rd quartile (75th quantile).</p>
<p>Centering and scaling happen independently on each feature by
computing the relevant statistics on the samples in the training
set. Median and interquartile range are then stored to be used on
later data using the <code class="docutils literal notranslate"><span class="pre">transform</span></code> method.</p>
<p>Standardization of a dataset is a common requirement for many
machine learning estimators. Typically this is done by removing the mean
and scaling to unit variance. However, outliers can often influence the
sample mean / variance in a negative way. In such cases, the median and
the interquartile range often give better results.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17.</span></p>
</div>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>with_centering</strong> (<em>boolean</em><em>, </em><em>True by default</em>) – If True, center the data before scaling.
This will cause <code class="docutils literal notranslate"><span class="pre">transform</span></code> to raise an exception when attempted on
sparse matrices, because centering them entails building a dense
matrix which in common use cases is likely to be too large to fit in
memory.</p></li>
<li><p><strong>with_scaling</strong> (<em>boolean</em><em>, </em><em>True by default</em>) – If True, scale the data to interquartile range.</p></li>
<li><p><strong>quantile_range</strong> (<em>tuple</em><em> (</em><em>q_min</em><em>, </em><em>q_max</em><em>)</em><em>, </em><em>0.0 &lt; q_min &lt; q_max &lt; 100.0</em>) – <p>Default: (25.0, 75.0) = (1st quantile, 3rd quantile) = IQR
Quantile range used to calculate <code class="docutils literal notranslate"><span class="pre">scale_</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.</span></p>
</div>
</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default is True</em>) – If False, try to avoid a copy and do inplace scaling instead.
This is not guaranteed to always work inplace; e.g. if the data is
not a NumPy array or scipy.sparse CSR matrix, a copy may still be
returned.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.RobustScaler.center_">
<code class="sig-name descname">center_</code><a class="headerlink" href="#ballet.eng.external.RobustScaler.center_" title="Permalink to this definition">¶</a></dt>
<dd><p>The median value for each feature in the training set.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of floats</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.RobustScaler.scale_">
<code class="sig-name descname">scale_</code><a class="headerlink" href="#ballet.eng.external.RobustScaler.scale_" title="Permalink to this definition">¶</a></dt>
<dd><p>The (scaled) interquartile range for each feature in the training set.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>scale_</em> attribute.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of floats</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">RobustScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span>
<span class="go">RobustScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[ 0. , -2. ,  0. ],</span>
<span class="go">       [-1. ,  0. ,  0.4],</span>
<span class="go">       [ 1. ,  0. , -1.6]])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">robust_scale</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.PCA</span></code></dt><dd><p>Further removes the linear correlation across features with ‘whiten=True’.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Median">https://en.wikipedia.org/wiki/Median</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Interquartile_range">https://en.wikipedia.org/wiki/Interquartile_range</a></p>
<dl class="py method">
<dt id="ballet.eng.external.RobustScaler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#RobustScaler.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RobustScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median and quantiles to be used for scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to compute the median and quantiles
used for later scaling along the features axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.RobustScaler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#RobustScaler.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RobustScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em>) – The data used to scale along the specified axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.RobustScaler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#RobustScaler.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RobustScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Center and scale the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em>) – The data used to scale along the specified axis.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.RollingMeanTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">RollingMeanTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">window</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#RollingMeanTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RollingMeanTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.RollingMeanTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#RollingMeanTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RollingMeanTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.RollingMeanTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#RollingMeanTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.RollingMeanTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.SeasonalTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">SeasonalTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seasonal_period</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">pred_stride</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#SeasonalTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SeasonalTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skits.feature_extraction.AutoregressiveTransformer</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.SimpleImputer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">SimpleImputer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#SimpleImputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SimpleImputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute._base._BaseImputer</span></code></p>
<p>Imputation transformer for completing missing values.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span><cite>SimpleImputer</cite> replaces the previous <cite>sklearn.preprocessing.Imputer</cite>
estimator which is now removed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_values</strong> (<em>number</em><em>, </em><em>string</em><em>, </em><em>np.nan</em><em> (</em><em>default</em><em>) or </em><em>None</em>) – The placeholder for the missing values. All occurrences of
<cite>missing_values</cite> will be imputed. For pandas’ dataframes with
nullable integer dtypes with missing values, <cite>missing_values</cite>
should be set to <cite>np.nan</cite>, since <cite>pd.NA</cite> will be converted to <cite>np.nan</cite>.</p></li>
<li><p><strong>strategy</strong> (<em>string</em><em>, </em><em>default='mean'</em>) – <p>The imputation strategy.</p>
<ul>
<li><p>If “mean”, then replace missing values using the mean along
each column. Can only be used with numeric data.</p></li>
<li><p>If “median”, then replace missing values using the median along
each column. Can only be used with numeric data.</p></li>
<li><p>If “most_frequent”, then replace missing using the most frequent
value along each column. Can be used with strings or numeric data.</p></li>
<li><p>If “constant”, then replace missing values with fill_value. Can be
used with strings or numeric data.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20: </span>strategy=”constant” for fixed value imputation.</p>
</div>
</p></li>
<li><p><strong>fill_value</strong> (<em>string</em><em> or </em><em>numerical value</em><em>, </em><em>default=None</em>) – When strategy == “constant”, fill_value is used to replace all
occurrences of missing_values.
If left to the default, fill_value will be 0 when imputing numerical
data and “missing_value” for strings or object data types.</p></li>
<li><p><strong>verbose</strong> (<em>integer</em><em>, </em><em>default=0</em>) – Controls the verbosity of the imputer.</p></li>
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – <p>If True, a copy of X will be created. If False, imputation will
be done in-place whenever possible. Note that, in the following cases,
a new copy will always be made, even if <cite>copy=False</cite>:</p>
<ul>
<li><p>If X is not an array of floating values;</p></li>
<li><p>If X is encoded as a CSR matrix;</p></li>
<li><p>If add_indicator=True.</p></li>
</ul>
</p></li>
<li><p><strong>add_indicator</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – If True, a <a class="reference internal" href="#ballet.eng.external.MissingIndicator" title="ballet.eng.external.MissingIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MissingIndicator</span></code></a> transform will stack onto output
of the imputer’s transform. This allows a predictive estimator
to account for missingness despite imputation. If a feature has no
missing values at fit/train time, the feature won’t appear on
the missing indicator even if there are missing values at
transform/test time.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.SimpleImputer.statistics_">
<code class="sig-name descname">statistics_</code><a class="headerlink" href="#ballet.eng.external.SimpleImputer.statistics_" title="Permalink to this definition">¶</a></dt>
<dd><p>The imputation fill value for each feature.
Computing statistics can result in <cite>np.nan</cite> values.
During <a class="reference internal" href="#ballet.eng.external.SimpleImputer.transform" title="ballet.eng.external.SimpleImputer.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a>, features corresponding to <cite>np.nan</cite>
statistics will be discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>array of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.SimpleImputer.indicator_">
<code class="sig-name descname">indicator_</code><a class="headerlink" href="#ballet.eng.external.SimpleImputer.indicator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator used to add binary indicators for missing values.
<code class="docutils literal notranslate"><span class="pre">None</span></code> if add_indicator is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.impute.MissingIndicator</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">IterativeImputer</span></code></dt><dd><p>Multivariate imputation of missing values.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imp_mean</span><span class="o">.</span><span class="n">fit</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="go">SimpleImputer()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">9</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">imp_mean</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">[[ 7.   2.   3. ]</span>
<span class="go"> [ 4.   3.5  6. ]</span>
<span class="go"> [10.   3.5  9. ]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Columns which only contained missing values at <a class="reference internal" href="#ballet.eng.external.SimpleImputer.fit" title="ballet.eng.external.SimpleImputer.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> are discarded
upon <a class="reference internal" href="#ballet.eng.external.SimpleImputer.transform" title="ballet.eng.external.SimpleImputer.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a> if strategy is not “constant”.</p>
<dl class="py method">
<dt id="ballet.eng.external.SimpleImputer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#SimpleImputer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SimpleImputer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the imputer on X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input data, where <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> is the number of samples and
<code class="docutils literal notranslate"><span class="pre">n_features</span></code> is the number of features.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#ballet.eng.external.SimpleImputer" title="ballet.eng.external.SimpleImputer">SimpleImputer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.SimpleImputer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/impute/_base.html#SimpleImputer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SimpleImputer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Impute all missing values in X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – The input data to complete.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.SparseRandomProjection">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">SparseRandomProjection</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/random_projection.html#SparseRandomProjection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SparseRandomProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.random_projection.BaseRandomProjection</span></code></p>
<p>Reduce dimensionality through sparse random projection</p>
<p>Sparse random matrix is an alternative to dense random
projection matrix that guarantees similar embedding quality while being
much more memory efficient and allowing faster computation of the
projected data.</p>
<p>If we note <cite>s = 1 / density</cite> the components of the random matrix are
drawn from:</p>
<blockquote>
<div><ul class="simple">
<li><p>-sqrt(s) / sqrt(n_components)   with probability 1 / 2s</p></li>
<li><p>0                              with probability 1 - 1 / s</p></li>
<li><p>+sqrt(s) / sqrt(n_components)   with probability 1 / 2s</p></li>
</ul>
</div></blockquote>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.13.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_components</strong> (<em>int</em><em> or </em><em>'auto'</em><em>, </em><em>optional</em><em> (</em><em>default = 'auto'</em><em>)</em>) – <p>Dimensionality of the target projection space.</p>
<p>n_components can be automatically adjusted according to the
number of samples in the dataset and the bound given by the
Johnson-Lindenstrauss lemma. In that case the quality of the
embedding is controlled by the <code class="docutils literal notranslate"><span class="pre">eps</span></code> parameter.</p>
<p>It should be noted that Johnson-Lindenstrauss lemma can yield
very conservative estimated of the required number of components
as it makes no assumption on the structure of the dataset.</p>
</p></li>
<li><p><strong>density</strong> (<em>float in range</em><em> ]</em><em>0</em><em>, </em><em>1</em><em>]</em><em>, </em><em>optional</em><em> (</em><em>default='auto'</em><em>)</em>) – <p>Ratio of non-zero component in the random projection matrix.</p>
<p>If density = ‘auto’, the value is set to the minimum density
as recommended by Ping Li et al.: 1 / sqrt(n_features).</p>
<p>Use density = 1 / 3.0 if you want to reproduce the results from
Achlioptas, 2001.</p>
</p></li>
<li><p><strong>eps</strong> (<em>strictly positive float</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0.1</em><em>)</em>) – <p>Parameter to control the quality of the embedding according to
the Johnson-Lindenstrauss lemma when n_components is set to
‘auto’.</p>
<p>Smaller values lead to better embedding and higher number of
dimensions (n_components) in the target projection space.</p>
</p></li>
<li><p><strong>dense_output</strong> (<em>boolean</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – <p>If True, ensure that the output of the random projection is a
dense numpy array even if the input and random projection matrix
are both sparse. In practice, if the number of components is
small the number of zero components in the projected data will
be very small and it will be more CPU and memory efficient to
use a dense representation.</p>
<p>If False, the projected data uses a sparse representation if
the input is sparse.</p>
</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>RandomState instance</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Controls the pseudo random number generator used to generate the
projection matrix at fit time.
Pass an int for reproducible output across multiple function calls.
See <span class="xref std std-term">Glossary</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.SparseRandomProjection.n_components_">
<code class="sig-name descname">n_components_</code><a class="headerlink" href="#ballet.eng.external.SparseRandomProjection.n_components_" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete number of components computed when n_components=”auto”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.SparseRandomProjection.components_">
<code class="sig-name descname">components_</code><a class="headerlink" href="#ballet.eng.external.SparseRandomProjection.components_" title="Permalink to this definition">¶</a></dt>
<dd><p>Random matrix used for the projection.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>CSR matrix with shape [n_components, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.SparseRandomProjection.density_">
<code class="sig-name descname">density_</code><a class="headerlink" href="#ballet.eng.external.SparseRandomProjection.density_" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete density computed from when density = “auto”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float in range 0.0 - 1.0</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.random_projection</span> <span class="kn">import</span> <span class="n">SparseRandomProjection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">SparseRandomProjection</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_new</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_new</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3947)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># very few components are non-zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">transformer</span><span class="o">.</span><span class="n">components_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0.0100...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#ballet.eng.external.GaussianRandomProjection" title="ballet.eng.external.GaussianRandomProjection"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianRandomProjection</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id53"><span class="brackets">1</span></dt>
<dd><p>Ping Li, T. Hastie and K. W. Church, 2006,
“Very Sparse Random Projections”.
<a class="reference external" href="https://web.stanford.edu/~hastie/Papers/Ping/KDD06_rp.pdf">https://web.stanford.edu/~hastie/Papers/Ping/KDD06_rp.pdf</a></p>
</dd>
<dt class="label" id="id54"><span class="brackets">2</span></dt>
<dd><p>D. Achlioptas, 2001, “Database-friendly random projections”,
<a class="reference external" href="https://users.soe.ucsc.edu/~optas/papers/jl.pdf">https://users.soe.ucsc.edu/~optas/papers/jl.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.StandardScaler">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">StandardScaler</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#StandardScaler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.StandardScaler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Standardize features by removing the mean and scaling to unit variance</p>
<p>The standard score of a sample <cite>x</cite> is calculated as:</p>
<blockquote>
<div><p>z = (x - u) / s</p>
</div></blockquote>
<p>where <cite>u</cite> is the mean of the training samples or zero if <cite>with_mean=False</cite>,
and <cite>s</cite> is the standard deviation of the training samples or one if
<cite>with_std=False</cite>.</p>
<p>Centering and scaling happen independently on each feature by computing
the relevant statistics on the samples in the training set. Mean and
standard deviation are then stored to be used on later data using
<a class="reference internal" href="#ballet.eng.external.StandardScaler.transform" title="ballet.eng.external.StandardScaler.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a>.</p>
<p>Standardization of a dataset is a common requirement for many
machine learning estimators: they might behave badly if the
individual features do not more or less look like standard normally
distributed data (e.g. Gaussian with 0 mean and unit variance).</p>
<p>For instance many elements used in the objective function of
a learning algorithm (such as the RBF kernel of Support Vector
Machines or the L1 and L2 regularizers of linear models) assume that
all features are centered around 0 and have variance in the same
order. If a feature has a variance that is orders of magnitude larger
that others, it might dominate the objective function and make the
estimator unable to learn from other features correctly as expected.</p>
<p>This scaler can also be applied to sparse CSR or CSC matrices by passing
<cite>with_mean=False</cite> to avoid breaking the sparsity structure of the data.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>copy</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default True</em>) – If False, try to avoid a copy and do inplace scaling instead.
This is not guaranteed to always work inplace; e.g. if the data is
not a NumPy array or scipy.sparse CSR matrix, a copy may still be
returned.</p></li>
<li><p><strong>with_mean</strong> (<em>boolean</em><em>, </em><em>True by default</em>) – If True, center the data before scaling.
This does not work (and will raise an exception) when attempted on
sparse matrices, because centering them entails building a dense
matrix which in common use cases is likely to be too large to fit in
memory.</p></li>
<li><p><strong>with_std</strong> (<em>boolean</em><em>, </em><em>True by default</em>) – If True, scale the data to unit variance (or equivalently,
unit standard deviation).</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.StandardScaler.scale_">
<code class="sig-name descname">scale_</code><a class="headerlink" href="#ballet.eng.external.StandardScaler.scale_" title="Permalink to this definition">¶</a></dt>
<dd><p>Per feature relative scaling of the data. This is calculated using
<cite>np.sqrt(var_)</cite>. Equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">with_std=False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span><em>scale_</em></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray or None, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.StandardScaler.mean_">
<code class="sig-name descname">mean_</code><a class="headerlink" href="#ballet.eng.external.StandardScaler.mean_" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean value for each feature in the training set.
Equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">with_mean=False</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray or None, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.StandardScaler.var_">
<code class="sig-name descname">var_</code><a class="headerlink" href="#ballet.eng.external.StandardScaler.var_" title="Permalink to this definition">¶</a></dt>
<dd><p>The variance for each feature in the training set. Used to compute
<cite>scale_</cite>. Equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">with_std=False</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray or None, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.StandardScaler.n_samples_seen_">
<code class="sig-name descname">n_samples_seen_</code><a class="headerlink" href="#ballet.eng.external.StandardScaler.n_samples_seen_" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of samples processed by the estimator for each feature.
If there are not missing samples, the <code class="docutils literal notranslate"><span class="pre">n_samples_seen</span></code> will be an
integer, otherwise it will be an array.
Will be reset on new calls to fit, but increments across
<code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> calls.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int or array, shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">StandardScaler()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">mean_</span><span class="p">)</span>
<span class="go">[0.5 0.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="go">[[-1. -1.]</span>
<span class="go"> [-1. -1.]</span>
<span class="go"> [ 1.  1.]</span>
<span class="go"> [ 1.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>
<span class="go">[[3. 3.]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">scale</span></code></dt><dd><p>Equivalent function without the estimator API.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.decomposition.PCA</span></code></dt><dd><p>Further removes the linear correlation across features with ‘whiten=True’.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NaNs are treated as missing values: disregarded in fit, and maintained in
transform.</p>
<p>We use a biased estimator for the standard deviation, equivalent to
<cite>numpy.std(x, ddof=0)</cite>. Note that the choice of <cite>ddof</cite> is unlikely to
affect model performance.</p>
<p>For a comparison of the different scalers, transformers, and normalizers,
see <span class="xref std std-ref">examples/preprocessing/plot_all_scaling.py</span>.</p>
<dl class="py method">
<dt id="ballet.eng.external.StandardScaler.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#StandardScaler.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.StandardScaler.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean and std to be used for later scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p></li>
<li><p><strong>y</strong> – Ignored</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.StandardScaler.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#StandardScaler.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.StandardScaler.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale back the data to the original representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to scale along the features axis.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default: None</em><em>)</em>) – Copy the input X or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_tr</strong> – Transformed array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array-like, shape [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.StandardScaler.partial_fit">
<code class="sig-name descname">partial_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#StandardScaler.partial_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.StandardScaler.partial_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Online computation of mean and std on X for later scaling.</p>
<p>All of X is processed as a single batch. This is intended for cases
when <a class="reference internal" href="#ballet.eng.external.StandardScaler.fit" title="ballet.eng.external.StandardScaler.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> is not feasible due to very large number of
<cite>n_samples</cite> or because X is read from a continuous stream.</p>
<p>The algorithm for incremental mean and std is given in Equation 1.5a,b
in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. “Algorithms
for computing the sample variance: Analysis and recommendations.”
The American Statistician 37.3 (1983): 242-247:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>{array-like</em><em>, </em><em>sparse matrix}</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to compute the mean and standard deviation
used for later scaling along the features axis.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – Ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Transformer instance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.StandardScaler.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sklearn/preprocessing/_data.html#StandardScaler.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.StandardScaler.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform standardization by centering and scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data used to scale along the features axis.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default: None</em><em>)</em>) – Copy the input X or not.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.SumEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">SumEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/sum_coding.html#SumEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SumEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>Sum contrast coding for the encoding of categorical features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has unknown categories.  This can cause
unexpected changes in dimension in some cases.</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’, ‘value’, and ‘indicator’. The default is ‘value’. Warning: if indicator is used,
an extra column will be added in if the transform matrix has nan values.  This can cause
unexpected changes in dimension in some cases.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">SumEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 21 columns):</span>
<span class="go">intercept    506 non-null int64</span>
<span class="go">CRIM         506 non-null float64</span>
<span class="go">ZN           506 non-null float64</span>
<span class="go">INDUS        506 non-null float64</span>
<span class="go">CHAS_0       506 non-null float64</span>
<span class="go">NOX          506 non-null float64</span>
<span class="go">RM           506 non-null float64</span>
<span class="go">AGE          506 non-null float64</span>
<span class="go">DIS          506 non-null float64</span>
<span class="go">RAD_0        506 non-null float64</span>
<span class="go">RAD_1        506 non-null float64</span>
<span class="go">RAD_2        506 non-null float64</span>
<span class="go">RAD_3        506 non-null float64</span>
<span class="go">RAD_4        506 non-null float64</span>
<span class="go">RAD_5        506 non-null float64</span>
<span class="go">RAD_6        506 non-null float64</span>
<span class="go">RAD_7        506 non-null float64</span>
<span class="go">TAX          506 non-null float64</span>
<span class="go">PTRATIO      506 non-null float64</span>
<span class="go">B            506 non-null float64</span>
<span class="go">LSTAT        506 non-null float64</span>
<span class="go">dtypes: float64(20), int64(1)</span>
<span class="go">memory usage: 83.1 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id55"><span class="brackets">1</span></dt>
<dd><p>Contrast Coding Systems for Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/</a></p>
<dl class="footnote brackets">
<dt class="label" id="id56"><span class="brackets">2</span></dt>
<dd><p>Gregory Carey (2003). Coding Categorical Variables, from</p>
</dd>
</dl>
<p><a class="reference external" href="http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf">http://psych.colorado.edu/~carey/Courses/PSYC5741/handouts/Coding%20Categorical%20Variables%202006-03-03.pdf</a></p>
<dl class="py method">
<dt id="ballet.eng.external.SumEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/sum_coding.html#SumEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SumEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.SumEncoder.fit_sum_coding">
<em class="property">static </em><code class="sig-name descname">fit_sum_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">col</span></em>, <em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="n">handle_missing</span></em>, <em class="sig-param"><span class="n">handle_unknown</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/sum_coding.html#SumEncoder.fit_sum_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SumEncoder.fit_sum_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.SumEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/sum_coding.html#SumEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SumEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.SumEncoder.sum_coding">
<em class="property">static </em><code class="sig-name descname">sum_coding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em>, <em class="sig-param"><span class="n">mapping</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/sum_coding.html#SumEncoder.sum_coding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SumEncoder.sum_coding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.SumEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/sum_coding.html#SumEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.SumEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.TargetEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">TargetEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">min_samples_leaf</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">smoothing</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/target_encoder.html#TargetEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TargetEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>Target encoding for categorical features.</p>
<p>For the case of categorical target: features are replaced with a blend of posterior probability of the target
given particular categorical value and the prior probability of the target over all the training data.</p>
<p>For the case of continuous target: features are replaced with a blend of the expected value of the target
given particular categorical value and the expected value of the target over all the training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’  and ‘value’, defaults to ‘value’, which returns the target mean.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘error’, ‘return_nan’ and ‘value’, defaults to ‘value’, which returns the target mean.</p></li>
<li><p><strong>min_samples_leaf</strong> (<em>int</em>) – minimum samples to take category average into account.</p></li>
<li><p><strong>smoothing</strong> (<em>float</em>) – smoothing effect to balance categorical average vs prior. Higher value means stronger regularization.
The value must be strictly bigger than 0.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">TargetEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id57"><span class="brackets">1</span></dt>
<dd><p>A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://dl.acm.org/citation.cfm?id=507538">https://dl.acm.org/citation.cfm?id=507538</a></p>
<dl class="py method">
<dt id="ballet.eng.external.TargetEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/target_encoder.html#TargetEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TargetEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.TargetEncoder.fit_target_encoding">
<code class="sig-name descname">fit_target_encoding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/target_encoder.html#TargetEncoder.fit_target_encoding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TargetEncoder.fit_target_encoding" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.TargetEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/target_encoder.html#TargetEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TargetEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.TargetEncoder.target_encode">
<code class="sig-name descname">target_encode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X_in</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/target_encoder.html#TargetEncoder.target_encode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TargetEncoder.target_encode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.TargetEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/target_encoder.html#TargetEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TargetEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target info (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.TrendTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">TrendTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shift</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#TrendTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TrendTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<dl class="py method">
<dt id="ballet.eng.external.TrendTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#TrendTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TrendTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.TrendTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/skits/feature_extraction.html#TrendTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.TrendTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.UserInputDiscretiser">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">UserInputDiscretiser</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">binning_dict</span></em>, <em class="sig-param"><span class="n">return_object</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_boundaries</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#UserInputDiscretiser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.UserInputDiscretiser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The UserInputDiscretiser() divides continuous numerical variables
into contiguous intervals are arbitrarily entered by the user.</p>
<p>The user needs to enter a dictionary with variable names as keys, and a list of
the limits of the intervals as values. For example {‘var1’:[0, 10, 100, 1000],
‘var2’:[5, 10, 15, 20]}.</p>
<p>The UserInputDiscretiser() works only with numerical variables. The discretiser will
check if the dictionary entered by the user contains variables present in the training
set, and if these variables are cast as numerical, before doing any transformation.</p>
<p>Then it transforms the variables, that is, it sorts the values into the intervals,
transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>binning_dict</strong> (<em>dict</em>) – The dictionary with the variable : interval limits pairs, provided by the user. A
valid dictionary looks like this: {‘var1’:[0, 10, 100, 1000], ‘var2’:[5, 10, 15, 20]}.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether the numbers in the discrete variable should be returned as
numeric or as object. The decision is made by the user based on
whether they would like to proceed the engineering of the variable as
if it was numerical or categorical.</p></li>
<li><p><strong>return_boundaries</strong> (<em>bool</em><em>, </em><em>default=False</em>) – whether the output should be the interval boundaries. If True, it returns
the interval boundaries. If False, it returns integers.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.UserInputDiscretiser.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#UserInputDiscretiser.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.UserInputDiscretiser.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the user entered variables are in the train set and cast as numerical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to be transformed.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.UserInputDiscretiser.binner_dict_">
<code class="sig-name descname">binner_dict_</code><a class="headerlink" href="#ballet.eng.external.UserInputDiscretiser.binner_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {variable: interval limits} pairs used
to sort the values into discrete intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.UserInputDiscretiser.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisers.html#UserInputDiscretiser.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.UserInputDiscretiser.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the variable values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The transformed data with the discrete variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.WOEEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">WOEEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop_invariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_df</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">handle_unknown</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">handle_missing</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">random_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">randomized</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">0.05</span></em>, <em class="sig-param"><span class="n">regularization</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/woe.html#WOEEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WOEEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">category_encoders.utils.TransformerWithTargetMixin</span></code></p>
<p>Weight of Evidence coding for categorical features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<em>int</em>) – integer indicating verbosity of the output. 0 for none.</p></li>
<li><p><strong>cols</strong> (<em>list</em>) – a list of columns to encode, if None, all string columns will be encoded.</p></li>
<li><p><strong>drop_invariant</strong> (<em>bool</em>) – boolean for whether or not to drop columns with 0 variance.</p></li>
<li><p><strong>return_df</strong> (<em>bool</em>) – boolean for whether to return a pandas DataFrame from transform (otherwise it will be a numpy array).</p></li>
<li><p><strong>handle_missing</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which will assume WOE=0.</p></li>
<li><p><strong>handle_unknown</strong> (<em>str</em>) – options are ‘return_nan’, ‘error’ and ‘value’, defaults to ‘value’, which will assume WOE=0.</p></li>
<li><p><strong>randomized</strong> (<em>bool</em><em>,</em>) – adds normal (Gaussian) distribution noise into training data in order to decrease overfitting (testing data are untouched).</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – standard deviation (spread or “width”) of the normal distribution.</p></li>
<li><p><strong>regularization</strong> (<em>float</em>) – the purpose of regularization is mostly to prevent division by zero.
When regularization is 0, you may encounter division by zero.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">category_encoders</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_boston</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bunch</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">bunch</span><span class="o">.</span><span class="n">target</span> <span class="o">&gt;</span> <span class="mf">22.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bunch</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">bunch</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc</span> <span class="o">=</span> <span class="n">WOEEncoder</span><span class="p">(</span><span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;CHAS&#39;</span><span class="p">,</span> <span class="s1">&#39;RAD&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numeric_dataset</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">numeric_dataset</span><span class="o">.</span><span class="n">info</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="go">RangeIndex: 506 entries, 0 to 505</span>
<span class="go">Data columns (total 13 columns):</span>
<span class="go">CRIM       506 non-null float64</span>
<span class="go">ZN         506 non-null float64</span>
<span class="go">INDUS      506 non-null float64</span>
<span class="go">CHAS       506 non-null float64</span>
<span class="go">NOX        506 non-null float64</span>
<span class="go">RM         506 non-null float64</span>
<span class="go">AGE        506 non-null float64</span>
<span class="go">DIS        506 non-null float64</span>
<span class="go">RAD        506 non-null float64</span>
<span class="go">TAX        506 non-null float64</span>
<span class="go">PTRATIO    506 non-null float64</span>
<span class="go">B          506 non-null float64</span>
<span class="go">LSTAT      506 non-null float64</span>
<span class="go">dtypes: float64(13)</span>
<span class="go">memory usage: 51.5 KB</span>
<span class="go">None</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id58"><span class="brackets">1</span></dt>
<dd><p>Weight of Evidence (WOE) and Information Value Explained, from</p>
</dd>
</dl>
<p><a class="reference external" href="https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html">https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html</a></p>
<dl class="py method">
<dt id="ballet.eng.external.WOEEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/woe.html#WOEEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WOEEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit encoder according to X and binary y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – Training vectors, where n_samples is the number of samples
and n_features is the number of features.</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>]</em>) – Binary target values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – Returns self.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>encoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.WOEEncoder.get_feature_names">
<code class="sig-name descname">get_feature_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/woe.html#WOEEncoder.get_feature_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WOEEncoder.get_feature_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of all transformed / added columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>feature_names</strong> – A list with all feature names transformed or added.
Note: potentially dropped features are not included!</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.WOEEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">override_return_df</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/category_encoders/woe.html#WOEEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WOEEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the transformation to new categorical data. When the data are used for model training,
it is important to also pass the target in order to apply leave one out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – </p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape =</em><em> [</em><em>n_samples</em><em>] </em><em>when transform by leave one out</em>) – None, when transform without target information (such as transform test set)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – Transformed values with encoding applied.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array, shape = [n_samples, n_numeric + N]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.Winsorizer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">Winsorizer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distribution</span><span class="o">=</span><span class="default_value">'gaussian'</span></em>, <em class="sig-param"><span class="n">tail</span><span class="o">=</span><span class="default_value">'right'</span></em>, <em class="sig-param"><span class="n">fold</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">missing_values</span><span class="o">=</span><span class="default_value">'raise'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#Winsorizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Winsorizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>The Winsorizer() caps maximum and / or minimum values of a variable.</p>
<p>The Winsorizer() works only with numerical variables. A list of variables can
be indicated. Alternatively, the Winsorizer() will select all numerical
variables in the train set.</p>
<p>The Winsorizer() first calculates the capping values at the end of the
distribution. The values are determined using 1) a Gaussian approximation,
2) the inter-quantile range proximity rule or 3) percentiles.</p>
<p>Gaussian limits:</p>
<blockquote>
<div><p>right tail: mean + 3* std</p>
<p>left tail: mean - 3* std</p>
</div></blockquote>
<p>IQR limits:</p>
<blockquote>
<div><p>right tail: 75th quantile + 3* IQR</p>
<p>left tail:  25th quantile - 3* IQR</p>
</div></blockquote>
<p>where IQR is the inter-quartile range: 75th quantile - 25th quantile.</p>
<p>percentiles or quantiles:</p>
<blockquote>
<div><p>right tail: 95th percentile</p>
<p>left tail:  5th percentile</p>
</div></blockquote>
<p>You can select how far out to cap the maximum or minimum values with the
parameter ‘fold’.</p>
<p>If distribution=’gaussian’ fold gives the value to multiply the std.</p>
<p>If distribution=’skewed’ fold is the value to multiply the IQR.</p>
<p>If distribution=’quantile’, fold is the percentile on each tail that should
be censored. For example, if fold=0.05, the limits will be the 5th and 95th
percentiles. If fold=0.1, the limits will be the 10th and 90th percentiles.</p>
<p>The transformer first finds the values at one or both tails of the distributions
(fit).</p>
<p>The transformer then caps the variables (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distribution</strong> (<em>str</em><em>, </em><em>default=gaussian</em>) – <p>Desired distribution. Can take ‘gaussian’, ‘skewed’ or ‘quantiles’.</p>
<p>gaussian: the transformer will find the maximum and / or minimum values to
cap the variables using the Gaussian approximation.</p>
<p>skewed: the transformer will find the boundaries using the IQR proximity rule.</p>
<p>quantiles: the limits are given by the percentiles.</p>
</p></li>
<li><p><strong>tail</strong> (<em>str</em><em>, </em><em>default=right</em>) – Whether to cap outliers on the right, left or both tails of the distribution.
Can take ‘left’, ‘right’ or ‘both’.</p></li>
<li><p><strong>fold</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>default=3</em>) – <p>How far out to to place the capping values. The number that will multiply
the std or IQR to calculate the capping values. Recommended values, 2
or 3 for the gaussian approximation, or 1.5 or 3 for the IQR proximity
rule.</p>
<p>If distribution=’quantile’, then ‘fold’ indicates the percentile. So if
fold=0.05, the limits will be the 95th and 5th percentiles.
Note: Outliers will be removed up to a maximum of the 20th percentiles on both
sides. Thus, when distribution=’quantile’, then ‘fold’ takes values between 0
and 0.20.</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of variables for which the outliers will be capped. If None,
the transformer will find and select all numerical variables.</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='raise'</em>) – Indicates if missing values should be ignored or raised. Sometimes we want to remove
outliers in the raw, original data, sometimes, we may want to remove outliers in the
already pre-transformed data. If missing_values=’ignore’, the transformer will ignore
missing data when learning the capping parameters or transforming the data. If
missing_values=’raise’ the transformer will return an error if the training or other
datasets contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.Winsorizer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#Winsorizer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Winsorizer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the values that should be used to replace outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.Winsorizer.right_tail_caps_">
<code class="sig-name descname">right_tail_caps_</code><a class="headerlink" href="#ballet.eng.external.Winsorizer.right_tail_caps_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the maximum values at which variables
will be capped.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.external.Winsorizer.left_tail_caps_">
<code class="sig-name descname">left_tail_caps_</code><a class="headerlink" href="#ballet.eng.external.Winsorizer.left_tail_caps_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the minimum values at which variables
will be capped.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.Winsorizer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outlier_removers.html#Winsorizer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.Winsorizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Caps the variable values, that is, censors outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe with the capped variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.WoERatioCategoricalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">WoERatioCategoricalEncoder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encoding_method</span><span class="o">=</span><span class="default_value">'woe'</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#WoERatioCategoricalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WoERatioCategoricalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseCategoricalTransformer</span></code></p>
<p>The WoERatioCategoricalEncoder() replaces categories by the weight of evidence
or by the ratio between the probability of the target = 1 and the probability
of the  target = 0.</p>
<p>The weight of evidence is given by: np.log(P(X=xj|Y = 1)/P(X=xj|Y=0))</p>
<p>The target probability ratio is given by: p(1) / p(0)</p>
<p>And the log of the target probability ratio is: np.log( p(1) / p(0) )</p>
<p>Note: This categorical encoding is exclusive for binary classification.</p>
<p>For example in the variable colour, if the mean of the target = 1 for blue
is 0.8 and the mean of the target = 0  is 0.2, blue will be replaced by:
np.log(0.8/0.2) = 1.386 if log_ratio is selected. Alternatively, blue will be
replaced by 0.8 / 0.2 = 4 if ratio is selected.</p>
<p>For details on the calculation of the weight of evidence visit:
<a class="reference external" href="https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html">https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html</a></p>
<p>Note: the division by 0 is not defined and the log(0) is not defined.
Thus, if p(0) = 0 for the ratio encoder, or either p(0) = 0 or p(1) = 0 for
woe or log_ratio, in any of the variables, the encoder will return an error.</p>
<p>The encoder will encode only categorical variables (type ‘object’). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first maps the categories to the numbers for each variable (fit).</p>
<p>The encoder then transforms the categories into the mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default=woe</em>) – <p>Desired method of encoding.</p>
<p>’woe’: weight of evidence</p>
<p>’ratio’ : probability ratio</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.external.WoERatioCategoricalEncoder.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#WoERatioCategoricalEncoder.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WoERatioCategoricalEncoder.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the numbers that should be used to replace the categories in each
variable. That is the WoE or ratio of probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the categorical variables.</p></li>
<li><p><strong>y</strong> (<em>pandas series.</em>) – Target, must be binary [0,1].</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.WoERatioCategoricalEncoder.encoder_dict_">
<code class="sig-name descname">encoder_dict_</code><a class="headerlink" href="#ballet.eng.external.WoERatioCategoricalEncoder.encoder_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {category: WoE / ratio} pairs per variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.WoERatioCategoricalEncoder.inverse_transform">
<code class="sig-name descname">inverse_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#WoERatioCategoricalEncoder.inverse_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WoERatioCategoricalEncoder.inverse_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data back to the original representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_transformed</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The transformed dataframe.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X</strong> – The un-transformed dataframe, that is, containing the original values
of the categorical variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.WoERatioCategoricalEncoder.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/categorical_encoders.html#WoERatioCategoricalEncoder.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.WoERatioCategoricalEncoder.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) – The input samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe containing categories replaced by numbers.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.external.YeoJohnsonTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ballet.eng.external.</code><code class="sig-name descname">YeoJohnsonTransformer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#YeoJohnsonTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.YeoJohnsonTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The YeoJohnsonTransformer() applies the Yeo-Johnson transformation to the
numerical variables.</p>
<p>The Yeo-Johnson transformation implemented by this transformer is that of
SciPy.stats:
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html</a></p>
<p>The YeoJohnsonTransformer() works only with numerical variables.</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) – The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.external.YeoJohnsonTransformer.lamda_dict_">
<code class="sig-name descname">lamda_dict_</code><a class="headerlink" href="#ballet.eng.external.YeoJohnsonTransformer.lamda_dict_" title="Permalink to this definition">¶</a></dt>
<dd><p>The dictionary containing the {variable: best lambda for the Yeo-Johnson
transformation} pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.YeoJohnsonTransformer.fit">
<code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#YeoJohnsonTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.YeoJohnsonTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Learns the optimal lambda for the Yeo-Johnson transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The training input samples.
Can be the entire dataframe, not just the variables to transform.</p></li>
<li><p><strong>y</strong> (<em>None</em>) – y is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.external.YeoJohnsonTransformer.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/variable_transformers.html#YeoJohnsonTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ballet.eng.external.YeoJohnsonTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the Yeo-Johnson transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) – The data to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> – The dataframe with the transformed variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ballet.eng.feature_engine.html" class="btn btn-neutral float-right" title="ballet.eng.feature_engine module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ballet.eng.category_encoders.html" class="btn btn-neutral float-left" title="ballet.eng.category_encoders module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018, Micah Smith

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>