

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>ballet.eng.feature_engine module &mdash; ballet 0.12.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ballet.eng.featuretools module" href="ballet.eng.featuretools.html" />
    <link rel="prev" title="ballet.eng.external module" href="ballet.eng.external.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ballet
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../readme.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../readme.html#next-steps">Next steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#stable-release">Stable release</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#from-source">From source</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">User Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../maintainer_guide.html">Maintainer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#creating-a-ballet-project">Creating a Ballet project</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#project-instantiation">Project instantiation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#project-installation">Project installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#collaboration-via-git-and-github">Collaboration via git and GitHub</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../maintainer_guide.html#automatic-repository-creation">Automatic repository creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../maintainer_guide.html#manual-repository-creation">Manual repository creation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#enabling-continuous-integration">Enabling continuous integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#installing-bots">Installing bots</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#developing-new-features">Developing new features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#validating-features">Validating features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../maintainer_guide.html#pruning-features">Pruning features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#applying-the-feature-engineering-pipeline">Applying the feature engineering pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../maintainer_guide.html#updating-the-framework">Updating the framework</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributor_guide.html">Contributor Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#cloud-feature-development-workflow">Cloud Feature Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#launch-assemble">Launch Assembl√©</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#work-in-a-notebook">Work in a notebook</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#authenticate-with-github">Authenticate with GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#develop-a-new-feature">Develop a new feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#test-your-feature">Test your feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#submit-your-feature">Submit your feature</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#local-feature-development-workflow">Local Feature Development Workflow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#setup-your-development-environment">Setup your development environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#fork-the-project">Fork the project</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#clone-your-fork">Clone your fork</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#create-a-virtualenv">Create a virtualenv</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#contributor-guide-develop-a-new-feature-local">Develop a new feature</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#update-and-install-the-project">Update and install the project</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#start-working-on-a-new-feature">Start working on a new feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#write-your-feature">Write your feature</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#contributor-guide-test-your-feature-local">Test your feature</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../contributor_guide.html#submit-the-feature">Submit the feature</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#option-1-git-workflow">Option 1: Git workflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="../contributor_guide.html#option-2-in-lab-workflow">Option 2: In-Lab Workflow</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#understanding-validation-results">Understanding Validation Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributor_guide.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../feature_engineering_guide.html">Feature Engineering Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#feature-definitions">Feature Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#why">Why?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#writing-features">Writing features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#a-first-example">A first example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#a-second-example">A second example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#a-third-example">A third example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#input-types-and-conversions">Input types and conversions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#transformers">Transformers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#feature-engineering-pipelines">Feature engineering pipelines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#feature-engineering-primitives">Feature engineering primitives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#operating-on-groups">Operating on groups</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#addressing-missing-values">Addressing missing values</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#operating-on-time-series-data">Operating on time series data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#other-primitives">Other primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#external-libraries">External libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#pandas-ballet-examples">Pandas ‚áî Ballet Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#rolling-your-own-transformers">Rolling your own transformers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../feature_engineering_guide.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../feature_engineering_guide.html#further-reading">Further reading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#how-can-i-check-the-performance-of-a-feature">How can I check the performance of a feature?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#there-was-an-error-submitting-my-feature-using-assemble-in-jupyter-lab">There was an error submitting my feature using Assembl√© in Jupyter Lab.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#my-feature-has-a-valid-api-locally-why-was-it-rejected">My feature has a valid API locally, why was it rejected?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#why-did-my-feature-fail-the-feature-acceptance-validation">Why did my feature fail the feature acceptance validation?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#my-feature-relies-on-a-new-library-how-can-i-add-it-to-the-project">My feature relies on a new library, how can I add it to the project?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq.html#how-can-i-learn-to-write-better-features">How can I learn to write better features?</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="ballet.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="ballet.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="ballet.eng.html">ballet.eng package</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="ballet.eng.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ballet.util.html">ballet.util package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ballet.util.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ballet.validation.html">ballet.validation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ballet.validation.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="ballet.validation.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ballet.html#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ballet.cli.html">ballet.cli module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.client.html">ballet.client module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.compat.html">ballet.compat module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.contrib.html">ballet.contrib module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.exc.html">ballet.exc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.feature.html">ballet.feature module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.pipeline.html">ballet.pipeline module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.project.html">ballet.project module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.templating.html">ballet.templating module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.transformer.html">ballet.transformer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="ballet.update.html">ballet.update module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cli_reference.html">CLI Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-quickstart">quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-start-new-feature">start-new-feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-update-project-template">update-project-template</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cli_reference.html#ballet-validate">validate</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Development Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#types-of-contributions">Types of Contributions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#report-bugs">Report Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#fix-bugs">Fix Bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#implement-features">Implement Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#write-documentation">Write Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../contributing.html#submit-feedback">Submit Feedback</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#get-started">Get Started!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#pull-request-guidelines">Pull Request Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#tips">Tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributing.html#deploying">Deploying</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Credits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../authors.html#development-lead">Development Lead</a></li>
<li class="toctree-l2"><a class="reference internal" href="../authors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../history.html">History</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id1">0.12.0 (2021-03-10)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id2">0.11.0 (2021-03-04)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id3">0.10.0 (2021-02-23)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id4">0.9.0 (2021-02-16)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id5">0.8.2 (2021-02-16)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id6">0.8.1 (2021-02-16)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id7">0.8.0 (2021-02-02)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id8">0.7.11 (2020-09-16)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id9">0.7.10 (2020-09-08)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id10">0.7.9 (2020-08-15)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id11">0.7.8 (2020-08-13)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id12">0.7.7 (2020-08-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id13">0.7.6 (2020-08-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id14">0.7.5 (2020-08-03)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id15">0.7.4 (2020-07-22)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id16">0.7.3 (2020-07-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id17">0.7.2 (2020-07-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id18">0.7.1 (2020-07-20)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id19">0.7 (2020-07-17)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id20">0.6 (2019-11-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id21">0.5 (2018-10-14)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id22">0.4 (2018-09-21)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id23">0.3 (2018-04-28)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id24">0.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../history.html#id25">0.1</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ballet</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="ballet.html">ballet package</a> &raquo;</li>
        
          <li><a href="ballet.eng.html">ballet.eng package</a> &raquo;</li>
        
      <li>ballet.eng.feature_engine module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/HDI-Project/ballet/blob/master/docs/api/ballet.eng.feature_engine.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-ballet.eng.feature_engine">
<span id="ballet-eng-feature-engine-module"></span><h1>ballet.eng.feature_engine module<a class="headerlink" href="#module-ballet.eng.feature_engine" title="Permalink to this headline">¬∂</a></h1>
<dl class="py class">
<dt id="ballet.eng.feature_engine.AddMissingIndicator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">AddMissingIndicator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">missing_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/missing_indicator.html#AddMissingIndicator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.AddMissingIndicator" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>The AddMissingIndicator() adds an additional column or binary variable that
indicates if data is missing.</p>
<p>AddMissingIndicator() will add as many missing indicators as variables
indicated by the user, or variables with missing data in the train set.</p>
<p>The AddMissingIndicator() works for both numerical and categorical variables.
The user can pass a list with the variables for which the missing indicators
should be added as a list. Alternatively, the imputer will select and add missing
indicators to all variables in the training set that show missing data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_only</strong> (<em>bool</em><em>, </em><em>defatult=True</em>) ‚Äì <p>Indicates if missing indicators should be added to variables with missing
data or to all variables.</p>
<p>True: indicators will be created only for those variables that showed
missing data during fit.</p>
<p>False: indicators will be created for all variables</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will find and
select all variables with missing data.</p></li>
<li><p><strong>**Note**</strong> ‚Äì </p></li>
<li><p><strong>transformer will first select all variables</strong><strong> or </strong><strong>all user entered</strong> (<em>The</em>) ‚Äì </p></li>
<li><p><strong>and if how=missing_only</strong> (<em>variables</em>) ‚Äì </p></li>
<li><p><strong>will re-select from the original group</strong> (<em>it</em>) ‚Äì </p></li>
<li><p><strong>those that show missing data in during fit.</strong> (<em>only</em>) ‚Äì </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.AddMissingIndicator.variables_">
<code class="sig-name descname"><span class="pre">variables_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.AddMissingIndicator.variables_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>List of variables for which the missing indicators will be created.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the variables for which the missing indicators will be created</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Add the missing indicators.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then trasnform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.AddMissingIndicator.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/missing_indicator.html#AddMissingIndicator.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.AddMissingIndicator.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the variables for which the missing indicators will be created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>self.variables_</strong> ‚Äì The list of variables for which missing indicators will be added.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.AddMissingIndicator.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/missing_indicator.html#AddMissingIndicator.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.AddMissingIndicator.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Add the binary missing indicators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The dataframe to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> ‚Äì The dataframe containing the additional binary variables.
Binary variables are named with the original variable name plus
‚Äò_na‚Äô.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.ArbitraryDiscretiser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">ArbitraryDiscretiser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binning_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_boundaries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/arbitrary.html#ArbitraryDiscretiser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryDiscretiser" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The ArbitraryDiscretiser() divides continuous numerical variables into contiguous
intervals which limits are determined arbitrarily by the user.</p>
<p>The user needs to enter a dictionary with variable names as keys, and a list of
the limits of the intervals as values. For example {‚Äòvar1‚Äô:[0, 10, 100, 1000],
‚Äòvar2‚Äô:[5, 10, 15, 20]}.</p>
<p>ArbitraryDiscretiser() will then sort var1 values into the intervals 0-10, 10-100
100-1000, and var2 into 5-10, 10-15 and 15-20. Similar to <cite>pandas.cut</cite>.</p>
<p>The  ArbitraryDiscretiser() works only with numerical variables. The discretiser
will check if the dictionary entered by the user contains variables present in the
training set, and if these variables are numerical, before doing any
transformation.</p>
<p>Then it transforms the variables, that is, it sorts the values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>binning_dict</strong> (<em>dict</em>) ‚Äì <p>The dictionary with the variable : interval limits pairs, provided by the user.
A valid dictionary looks like this:</p>
<p>binning_dict = {‚Äòvar1‚Äô:[0, 10, 100, 1000], ‚Äòvar2‚Äô:[5, 10, 15, 20]}.</p>
</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì <p>Whether the numbers in the discrete variable should be returned as
numeric or as object. The decision is made by the user based on
whether they would like to proceed the engineering of the variable as
if it was numerical or categorical.</p>
<p>Categorical encoders in Feature-engine work only with variables of type object,
thus, if you wish to encode the returned bins, set return_object to True.</p>
</p></li>
<li><p><strong>return_boundaries</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì whether the output, that is the bin names / values, should be the interval
boundaries. If True, it returns the interval boundaries. If False, it returns
integers.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.ArbitraryDiscretiser.binner_dict_">
<code class="sig-name descname"><span class="pre">binner_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryDiscretiser.binner_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the interval limits per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn any parameter.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Sort continuous variable values into the intervals.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.cut</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">https</span></code></dt><dd><p>//pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt id="ballet.eng.feature_engine.ArbitraryDiscretiser.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/arbitrary.html#ArbitraryDiscretiser.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryDiscretiser.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn any parameter.</p>
<p>Check dataframe and variables. Checks that the user entered variables are in
the train set and cast as numerical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset. Can be the entire dataframe, not just the
variables to be transformed.</p></li>
<li><p><strong>y</strong> (<em>None</em>) ‚Äì y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.ArbitraryDiscretiser.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/arbitrary.html#ArbitraryDiscretiser.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryDiscretiser.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Sort the variable values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The dataframe to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of the same size as the one used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The transformed data with the discrete variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.ArbitraryNumberImputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">ArbitraryNumberImputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arbitrary_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imputer_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/arbitrary_number.html#ArbitraryNumberImputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryNumberImputer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>The ArbitraryNumberImputer() replaces missing data in each variable by an arbitrary
value determined by the user. It works only with numerical variables.</p>
<p>We can impute all variables with the same number, in which case we need to define
the variables to impute in <cite>variables</cite> and the imputation number in
<cite>arbitrary_number</cite>. Alternatively, we can pass a dictionary of variable and numbers
to use for their imputation.</p>
<p>For example, we can impute varA and varB with 99 like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">transformer</span> <span class="o">=</span> <span class="n">ArbitraryNumberImputer</span><span class="p">(</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;varA&#39;</span><span class="p">,</span> <span class="s1">&#39;varB&#39;</span><span class="p">],</span>
        <span class="n">arbitrary_number</span> <span class="o">=</span> <span class="mi">99</span>
        <span class="p">)</span>

<span class="n">Xt</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, we can impute varA with 1 and varB with 99 like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">transformer</span> <span class="o">=</span> <span class="n">ArbitraryNumberImputer</span><span class="p">(</span>
        <span class="n">imputer_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;varA&#39;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;varB&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">]</span>
        <span class="p">)</span>

<span class="n">Xt</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arbitrary_number</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>default=999</em>) ‚Äì The number to be used to replace missing data.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will find and
select all numerical type variables. This parameter is used only if
<cite>imputer_dict</cite> is None.</p></li>
<li><p><strong>imputer_dict</strong> (<em>dict</em><em>, </em><em>default=None</em>) ‚Äì The dictionary of variables and the arbitrary numbers for their imputation.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.ArbitraryNumberImputer.imputer_dict_">
<code class="sig-name descname"><span class="pre">imputer_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryNumberImputer.imputer_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the values to replace NAs in each variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn parameters.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Impute missing data.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.imputation.EndTailImputer</span></code></p>
</div>
<dl class="py method">
<dt id="ballet.eng.feature_engine.ArbitraryNumberImputer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/arbitrary_number.html#ArbitraryNumberImputer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryNumberImputer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This method does not learn any parameter. Checks dataframe and finds numerical
variables, or checks that the variables entered by user are numerical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset.</p></li>
<li><p><strong>y</strong> (<em>None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì If there are no numerical variables in the df or the df is empty</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.ArbitraryNumberImputer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/arbitrary_number.html#ArbitraryNumberImputer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryNumberImputer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.ArbitraryOutlierCapper">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">ArbitraryOutlierCapper</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_capping_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_capping_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/artbitrary.html#ArbitraryOutlierCapper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryOutlierCapper" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.outliers.base_outlier.BaseOutlier</span></code></p>
<p>The ArbitraryOutlierCapper() caps the maximum or minimum values of a variable
at an arbitrary value indicated by the user.</p>
<p>The user must provide the maximum or minimum values that will be used
to cap each variable in a dictionary {feature:capping value}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_capping_dict</strong> (<em>dictionary</em><em>, </em><em>default=None</em>) ‚Äì Dictionary containing the user specified capping values for the right tail of
the distribution of each variable (maximum values).</p></li>
<li><p><strong>min_capping_dict</strong> (<em>dictionary</em><em>, </em><em>default=None</em>) ‚Äì Dictionary containing user specified capping values for the eft tail of the
distribution of each variable (minimum values).</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='raise'</em>) ‚Äì Indicates if missing values should be ignored or raised. If
<cite>missing_values=‚Äôraise‚Äô</cite> the transformer will return an error if the
training or the datasets to transform contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.ArbitraryOutlierCapper.right_tail_caps_">
<code class="sig-name descname"><span class="pre">right_tail_caps_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryOutlierCapper.right_tail_caps_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the maximum values at which variables will be capped.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.feature_engine.ArbitraryOutlierCapper.left_tail_caps_">
<code class="sig-name descname"><span class="pre">left_tail_caps_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryOutlierCapper.left_tail_caps_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the minimum values at which variables will be capped.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn any parameter.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Cap the variables.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data. Then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.ArbitraryOutlierCapper.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/artbitrary.html#ArbitraryOutlierCapper.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryOutlierCapper.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn any parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.ArbitraryOutlierCapper.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/artbitrary.html#ArbitraryOutlierCapper.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ArbitraryOutlierCapper.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Cap the variable values, that is, censors outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the capped variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.BoxCoxTransformer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">BoxCoxTransformer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/boxcox.html#BoxCoxTransformer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.BoxCoxTransformer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The BoxCoxTransformer() applies the BoxCox transformation to numerical
variables.</p>
<p>The Box-Cox transformation is defined as:</p>
<ul class="simple">
<li><p>T(Y)=(Y exp(Œª)‚àí1)/Œª if Œª!=0</p></li>
<li><p>log(Y) otherwise</p></li>
</ul>
<p>where Y is the response variable and Œª is the transformation parameter. Œª varies,
typically from -5 to 5. In the transformation, all values of Œª are considered and
the optimal value for a given variable is selected.</p>
<p>The BoxCox transformation implemented by this transformer is that of
SciPy.stats:
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.boxcox.html</a></p>
<p>The BoxCoxTransformer() works only with numerical positive variables (&gt;=0,
the transformer also works for zero values).</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.BoxCoxTransformer.lambda_dict_">
<code class="sig-name descname"><span class="pre">lambda_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.BoxCoxTransformer.lambda_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the best BoxCox exponent per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the optimal lambda for the BoxCox transformation.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Apply the BoxCox transformation.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to data, then transform it.</p>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id1"><span class="brackets">1</span></dt>
<dd><p>Box and Cox. ‚ÄúAn Analysis of Transformations‚Äù. Read at a RESEARCH MEETING,
1964.
<a class="reference external" href="https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/j.2517-6161.1964.tb00553.x">https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/j.2517-6161.1964.tb00553.x</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.BoxCoxTransformer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/boxcox.html#BoxCoxTransformer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.BoxCoxTransformer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the optimal lambda for the BoxCox transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì <ul class="simple">
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><ul class="simple">
<li><p>If there are no numerical variables in the df or the df is empty</p></li>
<li><p>If the variable(s) contain null values</p></li>
<li><p>If some variables contain zero values</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.BoxCoxTransformer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/boxcox.html#BoxCoxTransformer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.BoxCoxTransformer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Apply the BoxCox transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values.
    - If the dataframe not of the same size as that used in fit().
    - If some variables contain negative values.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.CategoricalImputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">CategoricalImputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imputation_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'missing'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Missing'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/categorical.html#CategoricalImputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CategoricalImputer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>The CategoricalImputer() replaces missing data in categorical variables
by a string like ‚ÄòMissing‚Äô or any other entered by the user. Alternatively, it
replaces missing data by the most frequent category.</p>
<p>The CategoricalVariableImputer() works only with categorical variables.</p>
<p>The user can pass a list with the variables to be imputed. Alternatively,
the CategoricalImputer() will automatically find and select all variables of type
object.</p>
<p><strong>Note</strong></p>
<p>If you want to impute numerical variables with this transformer, you first need to
cast them as object. It may well be that after the imputation, they are re-casted
by pandas as numeric. Thus, if planning to do categorical encoding with
feature-engine to this variables after the imputation, make sure to return the
variables as object by setting <cite>return_object=True</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imputation_method</strong> (<em>str</em><em>, </em><em>default=missing</em>) ‚Äì Desired method of imputation. Can be ‚Äòfrequent‚Äô or ‚Äòmissing‚Äô.</p></li>
<li><p><strong>fill_value</strong> (<em>str</em><em>, </em><em>default='Missing'</em>) ‚Äì Only used when <cite>imputation_method=‚Äômissing‚Äô</cite>. Can be used to set a
user-defined value to replace the missing data.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will find and
select all object type variables.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì If working with numerical variables cast as object, decide
whether to return the variables as numeric or re-cast them as object.
Note that pandas will re-cast them automatically as numeric after the
transformation with the mode.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.CategoricalImputer.imputer_dict_">
<code class="sig-name descname"><span class="pre">imputer_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.CategoricalImputer.imputer_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with most frequent category or string per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn more frequent category, or assign string to variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Impute missing data.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, than transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.CategoricalImputer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/categorical.html#CategoricalImputer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CategoricalImputer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the most frequent category if the imputation method is set to frequent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì If there are no categorical variables in the df or the df is empty</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.CategoricalImputer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/categorical.html#CategoricalImputer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CategoricalImputer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.CombineWithReferenceFeature">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">CombineWithReferenceFeature</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables_to_combine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['sub']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_variables_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ignore'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/creation/combine_with_reference_feature.html#CombineWithReferenceFeature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CombineWithReferenceFeature" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>CombineWithReferenceFeature() applies basic mathematical operations between one or
more reference variables and a group of variables, returning one or more additional
features as a result. That is, it sums, multiplies, substracts or divides a group of
features to or by a group of reference variables and returns the result into new
variables.</p>
<p>For example, if we have the variables <strong>number_payments_first_quarter</strong>,
<strong>number_payments_second_quarter</strong>, <strong>number_payments_third_quarter</strong>,
<strong>number_payments_fourth_quarter</strong>, and <strong>total_payments</strong> we can use
CombineWithReferenceFeature() to determine the percentage of total payments per
month as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">transformer</span> <span class="o">=</span> <span class="n">CombineWithReferenceFeature</span><span class="p">(</span>
    <span class="n">variables_to_combine</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;number_payments_first_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;number_payments_second_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;number_payments_third_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;number_payments_fourth_quarter&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="n">reference_variables</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;total_payments&#39;</span><span class="p">],</span>

    <span class="n">operations</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;div&#39;</span><span class="p">],</span>

    <span class="n">new_variables_name</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;perc_payments_first_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;perc_payments_second_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;perc_payments_third_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;perc_payments_fourth_quarter&#39;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">Xt</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The transformed X, Xt, will contain the additional features indicated in the
new_variables_name list plus the original set of variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables_to_combine</strong> (<em>list</em>) ‚Äì The list of numerical variables to be combined with the reference
variables.</p></li>
<li><p><strong>reference_variables</strong> (<em>list</em>) ‚Äì The list of numerical reference variables that will be added, multiplied,
or substracted from the variables_to_combine, or used as denominator for
division.</p></li>
<li><p><strong>operations</strong> (<em>list</em><em>, </em><em>default=</em><em>[</em><em>'sub'</em><em>]</em>) ‚Äì <p>The list of basic mathematical operations to be used in transformation.</p>
<p>If none, all of [‚Äòsub‚Äô, ‚Äòdiv‚Äô,‚Äôadd‚Äô,‚Äômul‚Äô] will be performed
over the variables. Alternatively, the user can enter the list of
operations to carry out.</p>
<p>Each operation should be a string and must be one of the elements
from the list: [‚Äòsub‚Äô, ‚Äòdiv‚Äô,‚Äôadd‚Äô,‚Äômul‚Äô]</p>
<p>Each operation will result in a new variable that will be added to the
transformed dataset.</p>
</p></li>
<li><p><strong>new_variables_names</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì <p>Names of the newly created variables. The user can enter a list with the
names for the newly created features (recommended). The user must enter
as many names as new features created by the transformer. The number of new
features is the number of operations times the number of reference variables
times the number of variables to combine.</p>
<p>Thus, if you want to perform 2 operations, sub and div, combining 4 variables
with 2 reference variables, you should enter 2 X 4 X 2 new variable names.</p>
<p>The name of the variables indicated by the user should coincide with the order
in which the  operations are performed by the transformer. The transformer will
first carry out ‚Äòsub‚Äô, then ‚Äòdiv‚Äô, then ‚Äòadd‚Äô and finally ‚Äòmul‚Äô.</p>
<p>If new_variable_names=None, the transformer will assign an arbitrary name
to the newly created features.</p>
</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='ignore'</em>) ‚Äì Indicates if missing values should be ignored or raised. If
missing_values=‚Äôignore‚Äô, the transformer will ignore missing data when
transforming the data. If missing_values=‚Äôraise‚Äô the transformer will return
an error if the training or the datasets to transform contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit</span> <span class="pre">:</span></code></dt>
<dd><p>This transformer does not learn parameters.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform</span> <span class="pre">:</span></code></dt>
<dd><p>Combine the variables with the mathematical operations.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform</span> <span class="pre">:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>Although the transformer in essence allows us to combine any feature with any of
the allowed mathematical operations, its used is intended mostly for the creation
of new features based on some domain knowledge. Typical examples within the
financial sector are:</p>
<ul class="simple">
<li><p>Ratio between income and debt to create the debt_to_income_ratio.</p></li>
<li><p>Subtraction of rent from income to obtain the disposable_income.</p></li>
</ul>
<dl class="py method">
<dt id="ballet.eng.feature_engine.CombineWithReferenceFeature.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/creation/combine_with_reference_feature.html#CombineWithReferenceFeature.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CombineWithReferenceFeature.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn any parameter.
Performs dataframe checks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì </p></li>
<li><p><strong>training input samples.</strong> (<em>The</em>) ‚Äì </p></li>
<li><p><strong>be the entire dataframe</strong> (<em>Can</em>) ‚Äì </p></li>
<li><p><strong>just the variables to transform.</strong> (<em>not</em>) ‚Äì </p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, or </em><em>np.array. Defaults to None.</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì If any of the reference variables contain null values and the
    mathematical operation is ‚Äòdiv‚Äô.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.CombineWithReferenceFeature.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/creation/combine_with_reference_feature.html#CombineWithReferenceFeature.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CombineWithReferenceFeature.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Combine the variables with the mathematical operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì </p></li>
<li><p><strong>data to transform.</strong> (<em>The</em>) ‚Äì </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>X</strong> (<em>Pandas dataframe, shape = [n_samples, n_features + n_operations]</em>)</p></li>
<li><p><em>The dataframe with the operations results added as columns.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.CountFrequencyEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">CountFrequencyEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'count'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/count_frequency.html#CountFrequencyEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CountFrequencyEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The CountFrequencyEncoder() replaces categories by either the count or the
percentage of observations per category.</p>
<p>For example in the variable colour, if 10 observations are blue, blue will
be replaced by 10. Alternatively, if 10% of the observations are blue, blue
will be replaced by 0.1.</p>
<p>The CountFrequencyEncoder() will encode only categorical variables
(type ‚Äòobject‚Äô). A list of variables to encode can be passed as argument.
Alternatively, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first maps the categories to the counts or frequencies for each
variable (fit). The encoder then replaces the categories by those mapped numbers
(transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default='count'</em>) ‚Äì <p>Desired method of encoding.</p>
<p>‚Äôcount‚Äô: number of observations per category</p>
<p>‚Äôfrequency‚Äô: percentage of observations per category</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em>) ‚Äì The list of categorical variables that will be encoded. If None, the
encoder will find and transform all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.CountFrequencyEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.CountFrequencyEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the count or frequency} per category, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the count or frequency per category, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Encode the categories to numbers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">inverse_transform:</span></code></dt>
<dd><p>Encode the numbers into the original categories.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>NAN are introduced when encoding categories that were not present in the training
dataset. If this happens, try grouping infrequent categories using the
RareLabelEncoder().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.encoding.RareLabelEncoder</span></code></p>
</div>
<dl class="py method">
<dt id="ballet.eng.feature_engine.CountFrequencyEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/count_frequency.html#CountFrequencyEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CountFrequencyEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the counts or frequencies which will be used to replace the categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset. Can be the entire dataframe, not just the
variables to be transformed.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default = None</em>) ‚Äì y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.CountFrequencyEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/count_frequency.html#CountFrequencyEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CountFrequencyEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Convert the encoded variable back to the original values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The transformed dataframe.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The un-transformed dataframe, with the categorical variables containing the
original values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.CountFrequencyEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/count_frequency.html#CountFrequencyEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.CountFrequencyEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The dataset to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If after encoding, NAN were introduced.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe containing the categories replaced by numbers.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.DecisionTreeDiscretiser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">DecisionTreeDiscretiser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'neg_mean_squared_error'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regression</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/decision_tree.html#DecisionTreeDiscretiser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeDiscretiser" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The DecisionTreeDiscretiser() replaces continuous numerical variables by discrete,
finite, values estimated by a decision tree.</p>
<p>The methods is inspired by the following article from the winners of the KDD
2009 competition:
<a class="reference external" href="http://www.mtome.com/Publications/CiML/CiML-v3-book.pdf">http://www.mtome.com/Publications/CiML/CiML-v3-book.pdf</a></p>
<p>The DecisionTreeDiscretiser() works only with numerical variables.
A list of variables can be passed as an argument. Alternatively, the
discretiser will automatically select all numerical variables.</p>
<p>The DecisionTreeDiscretiser() first trains a decision tree for each variable.</p>
<p>The DecisionTreeDiscretiser() then transforms the variables, that is,
makes predictions based on the variable values, using the trained decision
tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cv</strong> (<em>int</em><em>, </em><em>default=3</em>) ‚Äì Desired number of cross-validation fold to be used to fit the decision
tree.</p></li>
<li><p><strong>scoring</strong> (<em>str</em><em>, </em><em>default='neg_mean_squared_error'</em>) ‚Äì Desired metric to optimise the performance for the tree. Comes from
sklearn.metrics. See DecisionTreeRegressor or DecisionTreeClassifier
model evaluation documentation for more options:
<a class="reference external" href="https://scikit-learn.org/stable/modules/model_evaluation.html">https://scikit-learn.org/stable/modules/model_evaluation.html</a></p></li>
<li><p><strong>variables</strong> (<em>list</em>) ‚Äì The list of numerical variables that will be transformed. If None, the
discretiser will automatically select all numerical variables.</p></li>
<li><p><strong>regression</strong> (<em>boolean</em><em>, </em><em>default=True</em>) ‚Äì Indicates whether the discretiser should train a regression or a classification
decision tree.</p></li>
<li><p><strong>param_grid</strong> (<em>dictionary</em><em>, </em><em>default=None</em>) ‚Äì <p>The list of parameters over which the decision tree should be optimised
during the grid search. The param_grid can contain any of the permitted
parameters for Scikit-learn‚Äôs DecisionTreeRegressor() or
DecisionTreeClassifier().</p>
<p>If None, then param_grid = {‚Äòmax_depth‚Äô: [1, 2, 3, 4]}</p>
</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>default=None</em>) ‚Äì The random_state to initialise the training of the decision tree. It is one
of the parameters of the Scikit-learn‚Äôs DecisionTreeRegressor() or
DecisionTreeClassifier(). For reproducibility it is recommended to set
the random_state to an integer.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.DecisionTreeDiscretiser.binner_dict_">
<code class="sig-name descname"><span class="pre">binner_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeDiscretiser.binner_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary containing the fitted tree per variable.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.feature_engine.DecisionTreeDiscretiser.scores_dict_">
<code class="sig-name descname"><span class="pre">scores_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeDiscretiser.scores_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the score of the best decision tree, over the train set.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Fit a decision tree per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Replace continuous values by the predictions of the decision tree.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.tree.DecisionTreeClassifier</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.tree.DecisionTreeRegressor</span></code></p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">1</span></dt>
<dd><p>Niculescu-Mizil, et al. ‚ÄúWinning the KDD Cup Orange Challenge with Ensemble
Selection‚Äù. JMLR: Workshop and Conference Proceedings 7: 23-34. KDD 2009
<a class="reference external" href="http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf">http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.DecisionTreeDiscretiser.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/decision_tree.html#DecisionTreeDiscretiser.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeDiscretiser.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Fit the decision trees. One tree per variable to be transformed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset. Can be the entire dataframe, not just the
variables to be transformed.</p></li>
<li><p><strong>y</strong> (<em>pandas series.</em>) ‚Äì Target variable. Required to train the decision tree.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.DecisionTreeDiscretiser.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/decision_tree.html#DecisionTreeDiscretiser.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeDiscretiser.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replaces original variable with the predictions of the tree. The tree outcome
is finite, aka, discrete.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The input samples.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of the same size as the one used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X_transformed</strong> ‚Äì The dataframe with transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.DecisionTreeEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">DecisionTreeEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'arbitrary'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'neg_mean_squared_error'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regression</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/decision_tree.html#DecisionTreeEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The DecisionTreeEncoder() encodes categorical variables with predictions
of a decision tree model.</p>
<p>Each categorical feature is recoded by training a decision tree, typically of
limited depth (2, 3 or 4) using that feature alone, and let the tree directly
predict the target. The probabilistic predictions of this decision tree are used as
the new values of the original categorical feature, that now is linearly (or at
least monotonically) correlated with the target.</p>
<p>In practice, the categorical variable will be first encoded into integers with the
OrdinalCategoricalEncoder(). The integers can be assigned arbitrarily to the
categories or following the mean value of the target in each category. Then a
decision tree will fit the resulting numerical variable to predict the target
variable. Finally, the original categorical variable values will be replaced by the
predictions of the decision tree.</p>
<p>Note that a decision tree is fit per every single categorical variable to encode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default='arbitrary'</em>) ‚Äì <p>The categorical encoding method that will be used to encode the original
categories to numerical values.</p>
<p>‚Äôordered‚Äô: the categories are numbered in ascending order according to
the target mean value per category.</p>
<p>‚Äôarbitrary‚Äô : categories are numbered arbitrarily.</p>
</p></li>
<li><p><strong>cv</strong> (<em>int</em><em>, </em><em>default=3</em>) ‚Äì Desired number of cross-validation fold to be used to fit the decision
tree.</p></li>
<li><p><strong>scoring</strong> (<em>str</em><em>, </em><em>default='neg_mean_squared_error'</em>) ‚Äì Desired metric to optimise the performance for the decision tree. Comes from
sklearn.metrics. See the DecisionTreeRegressor or DecisionTreeClassifier
model evaluation documentation for more options:
<a class="reference external" href="https://scikit-learn.org/stable/modules/model_evaluation.html">https://scikit-learn.org/stable/modules/model_evaluation.html</a></p></li>
<li><p><strong>regression</strong> (<em>boolean</em><em>, </em><em>default=True</em>) ‚Äì Indicates whether the encoder should train a regression or a classification
decision tree.</p></li>
<li><p><strong>param_grid</strong> (<em>dictionary</em><em>, </em><em>default=None</em>) ‚Äì <p>The list of parameters over which the decision tree should be optimised
during the grid search. The param_grid can contain any of the permitted
parameters for Scikit-learn‚Äôs DecisionTreeRegressor() or
DecisionTreeClassifier().</p>
<p>If None, then param_grid = {‚Äòmax_depth‚Äô: [1, 2, 3, 4]}.</p>
</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>default=None</em>) ‚Äì The random_state to initialise the training of the decision tree. It is one
of the parameters of the Scikit-learn‚Äôs DecisionTreeRegressor() or
DecisionTreeClassifier(). For reproducibility it is recommended to set
the random_state to an integer.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.DecisionTreeEncoder.encoder_">
<code class="sig-name descname"><span class="pre">encoder_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeEncoder.encoder_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>sklearn Pipeline containing the ordinal encoder and the decision tree.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Fit a decision tree per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Replace categorical variable by the predictions of the decision tree.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>The authors designed this method originally, to work with numerical variables. We
can replace numerical variables by the preditions of a decision tree utilising the
DecisionTreeDiscretiser().</p>
<p>NAN are introduced when encoding categories that were not present in the training
dataset. If this happens, try grouping infrequent categories using the
RareLabelEncoder().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.ensemble.DecisionTreeRegressor</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.ensemble.DecisionTreeClassifier</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.discretisation.DecisionTreeDiscretiser</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.encoding.RareLabelEncoder</span></code></p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">1</span></dt>
<dd><p>Niculescu-Mizil, et al. ‚ÄúWinning the KDD Cup Orange Challenge with Ensemble
Selection‚Äù. JMLR: Workshop and Conference Proceedings 7: 23-34. KDD 2009
<a class="reference external" href="http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf">http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.DecisionTreeEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/decision_tree.html#DecisionTreeEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Fit a decision tree per variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
categorical variables.</p></li>
<li><p><strong>y</strong> (<em>pandas series.</em>) ‚Äì The target variable. Required to train the decision tree and for
ordered ordinal encoding.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.DecisionTreeEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/decision_tree.html#DecisionTreeEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>inverse_transform is not implemented for this transformer yet.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.DecisionTreeEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/decision_tree.html#DecisionTreeEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DecisionTreeEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace categorical variable by the predictions of the decision tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The input samples.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If after encoding, NAN were introduced.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì Dataframe with variables encoded with decision tree predictions.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.DropMissingData">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">DropMissingData</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">missing_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/drop_missing_data.html#DropMissingData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DropMissingData" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>works for both numerical and categorical variables. DropMissingData can
automatically select all the variables, or alternatively, all the variables with
missing data in the train set. Then the observations with NA will be dropped for
these variable groups.</p>
<p>The user has the option to indicate for which variables the observations with NA
should be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>missing_only</strong> (<em>bool</em><em>, </em><em>default=True</em>) ‚Äì If true, missing observations will be dropped only for the variables that were
seen to have NA in the train set, during fit. If False, observations with NA
will be dropped from all variables.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will find and
select all variables with missing data.</p></li>
<li><p><strong>**Note**</strong> ‚Äì </p></li>
<li><p><strong>transformer will first select all variables</strong><strong> or </strong><strong>all user entered</strong> (<em>The</em>) ‚Äì </p></li>
<li><p><strong>and if missing_only=True</strong> (<em>variables</em>) ‚Äì </p></li>
<li><p><strong>will re-select from the original group</strong> (<em>it</em>) ‚Äì </p></li>
<li><p><strong>those that show missing data in during fit</strong> (<em>only</em>) ‚Äì </p></li>
<li><p><strong>is in the train set.</strong> (<em>that</em>) ‚Äì </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.DropMissingData.variables_">
<code class="sig-name descname"><span class="pre">variables_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.DropMissingData.variables_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>List of variables for which the rows with NA will be deleted.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the variables for which the rows with NA will be deleted</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Remove observations with NA</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">return_na_data:</span></code></dt>
<dd><p>Returns the dataframe with the rows that contain NA .</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.DropMissingData.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/drop_missing_data.html#DropMissingData.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DropMissingData.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the variables for which the rows with NA will be deleted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.DropMissingData.return_na_data">
<code class="sig-name descname"><span class="pre">return_na_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/drop_missing_data.html#DropMissingData.return_na_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DropMissingData.return_na_data" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Returns the subset of the dataframe which contains the rows with missing values.
This method could be useful in production, in case we want to store the
observations that will not be fed into the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The dataset to from which rows containing NA should be retained.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The cdataframe portion that contains only the rows with missing values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [obs_with_na, features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.DropMissingData.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/drop_missing_data.html#DropMissingData.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.DropMissingData.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Remove rows with missing values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The dataframe to be transformed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>X_transformed</strong> ‚Äì The complete case dataframe for the selected variables, of shape
[n_samples - rows_with_na, n_features]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas dataframe</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.EndTailImputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">EndTailImputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imputation_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'right'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/end_tail.html#EndTailImputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EndTailImputer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>The EndTailImputer() transforms features by replacing missing data by a value at
either tail of the distribution. Ti works only with numerical variables.</p>
<p>The user can indicate the variables to be imputed in a list. Alternatively, the
EndTailImputer() will automatically find and select all variables of type numeric.</p>
<p>The imputer first calculates the values at the end of the distribution for each
variable (fit). The values at the end of the distribution are determined using
the Gaussian limits, the the IQR proximity rule limits, or a factor of the maximum
value:</p>
<dl class="simple">
<dt>Gaussian limits</dt><dd><ul class="simple">
<li><p>right tail: mean + 3*std</p></li>
<li><p>left tail: mean - 3*std</p></li>
</ul>
</dd>
<dt>IQR limits:</dt><dd><ul class="simple">
<li><p>right tail: 75th quantile + 3*IQR</p></li>
<li><p>left tail:  25th quantile - 3*IQR</p></li>
</ul>
</dd>
</dl>
<p>where IQR is the inter-quartile range = 75th quantile - 25th quantile</p>
<dl class="simple">
<dt>Maximum value:</dt><dd><ul class="simple">
<li><p>right tail: max * 3</p></li>
<li><p>left tail: not applicable</p></li>
</ul>
</dd>
</dl>
<p>You can change the factor that multiplies the std, IQR or the maximum value
using the parameter ‚Äòfold‚Äô.</p>
<p>The imputer then replaces the missing data with the estimated values (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imputation_method</strong> (<em>str</em><em>, </em><em>default=gaussian</em>) ‚Äì <p>Method to be used to find the replacement values. Can take ‚Äògaussian‚Äô,
‚Äòiqr‚Äô or ‚Äòmax‚Äô.</p>
<p><strong>gaussian</strong>: the imputer will use the Gaussian limits to find the values
to replace missing data.</p>
<p><strong>iqr</strong>: the imputer will use the IQR limits to find the values to replace
missing data.</p>
<p><strong>max</strong>: the imputer will use the maximum values to replace missing data. Note
that if ‚Äòmax‚Äô is passed, the parameter ‚Äòtail‚Äô is ignored.</p>
</p></li>
<li><p><strong>tail</strong> (<em>str</em><em>, </em><em>default=right</em>) ‚Äì Indicates if the values to replace missing data should be selected from the
right or left tail of the variable distribution. Can take values ‚Äòleft‚Äô or
‚Äòright‚Äô.</p></li>
<li><p><strong>fold</strong> (<em>int</em><em>, </em><em>default=3</em>) ‚Äì Factor to multiply the std, the IQR or the Max values. Recommended values
are 2 or 3 for Gaussian, or 1.5 or 3 for IQR.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will find and
select all variables of type numeric.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.EndTailImputer.imputer_dict_">
<code class="sig-name descname"><span class="pre">imputer_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.EndTailImputer.imputer_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the values at the end of the distribution per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn values to replace missing data.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Impute missing data.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.EndTailImputer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/end_tail.html#EndTailImputer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EndTailImputer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the values at the end of the variable distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì If there are no numerical variables in the df or the df is empty</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.EndTailImputer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/end_tail.html#EndTailImputer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EndTailImputer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.EqualFrequencyDiscretiser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">EqualFrequencyDiscretiser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_boundaries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/equal_frequency.html#EqualFrequencyDiscretiser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EqualFrequencyDiscretiser" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The EqualFrequencyDiscretiser() divides continuous numerical variables
into contiguous equal frequency intervals, that is, intervals that contain
approximately the same proportion of observations.</p>
<p>The interval limits are determined using <cite>pandas.qcut()</cite>, in other words,
the interval limits are determined by the quantiles. The number of intervals,
i.e., the number of quantiles in which the variable should be divided is
determined by the user.</p>
<p>The EqualFrequencyDiscretiser() works only with numerical variables.
A list of variables can be passed as argument. Alternatively, the discretiser
will automatically select and transform all numerical variables.</p>
<p>The EqualFrequencyDiscretiser() first finds the boundaries for the intervals or
quantiles for each variable.</p>
<p>Then it transforms the variables, that is, it sorts the values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>int</em><em>, </em><em>default=10</em>) ‚Äì Desired number of equal frequency intervals / bins. In other words the
number of quantiles in which the variables should be divided.</p></li>
<li><p><strong>variables</strong> (<em>list</em>) ‚Äì The list of numerical variables that will be discretised. If None, the
EqualFrequencyDiscretiser() will select all numerical variables.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì Whether the numbers in the discrete variable should be returned as
numeric or as object. The decision is made by the user based on
whether they would like to proceed the engineering of the variable as
if it was numerical or categorical.</p></li>
<li><p><strong>return_boundaries</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì whether the output should be the interval boundaries. If True, it returns
the interval boundaries. If False, it returns integers.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.EqualFrequencyDiscretiser.binner_dict_">
<code class="sig-name descname"><span class="pre">binner_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.EqualFrequencyDiscretiser.binner_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the interval limits per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Find the interval limits.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Sort continuous variable values into the intervals.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.qcut</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">https</span></code></dt><dd><p>//pandas.pydata.org/pandas-docs/stable/reference/api/pandas.qcut.html</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets">1</span></dt>
<dd><p>Kotsiantis and Pintelas, ‚ÄúData preprocessing for supervised leaning,‚Äù
International Journal of Computer Science,  vol. 1, pp. 111 117, 2006.</p>
</dd>
<dt class="label" id="id5"><span class="brackets">2</span></dt>
<dd><p>Dong. ‚ÄúBeating Kaggle the easy way‚Äù. Master Thesis.
<a class="reference external" href="https://www.ke.tu-darmstadt.de/lehre/arbeiten/studien/2015/Dong_Ying.pdf">https://www.ke.tu-darmstadt.de/lehre/arbeiten/studien/2015/Dong_Ying.pdf</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.EqualFrequencyDiscretiser.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/equal_frequency.html#EqualFrequencyDiscretiser.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EqualFrequencyDiscretiser.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the limits of the equal frequency intervals, that is the percentiles
for each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset. Can be the entire dataframe, not just the variables
to be transformed.</p></li>
<li><p><strong>y</strong> (<em>None</em>) ‚Äì y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.EqualFrequencyDiscretiser.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/equal_frequency.html#EqualFrequencyDiscretiser.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EqualFrequencyDiscretiser.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Sort the variable values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of the same size as the one used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The transformed data with the discrete variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.EqualWidthDiscretiser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">EqualWidthDiscretiser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_boundaries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/equal_width.html#EqualWidthDiscretiser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EqualWidthDiscretiser" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The EqualWidthDiscretiser() divides continuous numerical variables into
intervals of the same width, that is, equidistant intervals. Note that the
proportion of observations per interval may vary.</p>
<p>The size of the interval is calculated as:</p>
<div class="math notranslate nohighlight">
\[( max(X) - min(X) ) / bins\]</div>
<p>where bins, which is the number of intervals, should be determined by the user.</p>
<p>The interval limits are determined using <cite>pandas.cut()</cite>. The number of intervals
in which the variable should be divided must be indicated by the user.</p>
<p>The EqualWidthDiscretiser() works only with numerical variables.
A list of variables can be passed as argument. Alternatively, the discretiser
will automatically select all numerical variables.</p>
<p>The EqualWidthDiscretiser() first finds the boundaries for the intervals for
each variable. Then, it transforms the variables, that is, sorts the values into
the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bins</strong> (<em>int</em><em>, </em><em>default=10</em>) ‚Äì Desired number of equal width intervals / bins.</p></li>
<li><p><strong>variables</strong> (<em>list</em>) ‚Äì The list of numerical variables to transform. If None, the
discretiser will automatically select all numerical type variables.</p></li>
<li><p><strong>return_object</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì Whether the numbers in the discrete variable should be returned as
numeric or as object. The decision should be made by the user based on
whether they would like to proceed the engineering of the variable as
if it was numerical or categorical.</p></li>
<li><p><strong>return_boundaries</strong> (<em>bool</em><em>, </em><em>default=False</em>) ‚Äì whether the output should be the interval boundaries. If True, it returns
the interval boundaries. If False, it returns integers.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.EqualWidthDiscretiser.binner_dict_">
<code class="sig-name descname"><span class="pre">binner_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.EqualWidthDiscretiser.binner_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the interval limits per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Find the interval limits.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Sort continuous variable values into the intervals.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pandas.cut</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">https</span></code></dt><dd><p>//pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">1</span></dt>
<dd><p>Kotsiantis and Pintelas, ‚ÄúData preprocessing for supervised leaning,‚Äù
International Journal of Computer Science,  vol. 1, pp. 111 117, 2006.</p>
</dd>
<dt class="label" id="id7"><span class="brackets">2</span></dt>
<dd><p>Dong. ‚ÄúBeating Kaggle the easy way‚Äù. Master Thesis.
<a class="reference external" href="https://www.ke.tu-darmstadt.de/lehre/arbeiten/studien/2015/Dong_Ying.pdf">https://www.ke.tu-darmstadt.de/lehre/arbeiten/studien/2015/Dong_Ying.pdf</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.EqualWidthDiscretiser.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/equal_width.html#EqualWidthDiscretiser.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EqualWidthDiscretiser.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the boundaries of the equal width intervals / bins for each
variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset. Can be the entire dataframe, not just the variables
to be transformed.</p></li>
<li><p><strong>y</strong> (<em>None</em>) ‚Äì y is not needed in this encoder. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.EqualWidthDiscretiser.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/discretisation/equal_width.html#EqualWidthDiscretiser.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.EqualWidthDiscretiser.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Sort the variable values into the intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of the same size as the one used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The transformed data with the discrete variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.LogTransformer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">LogTransformer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'e'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/log.html#LogTransformer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.LogTransformer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The LogTransformer() applies the natural logarithm or the base 10 logarithm to
numerical variables. The natural logarithm is logarithm in base e.</p>
<p>The LogTransformer() only works with numerical non-negative values. If the variable
contains a zero or a negative value, the transformer will return an error.</p>
<p>A list of variables can be passed as an argument. Alternatively, the transformer
will automatically select and transform all variables of type numeric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base</strong> (<em>string</em><em>, </em><em>default='e'</em>) ‚Äì Indicates if the natural or base 10 logarithm should be applied. Can take
values ‚Äòe‚Äô or ‚Äò10‚Äô.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of numerical variables to be transformed. If None, the transformer
will find and select all numerical variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn parameters.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Transforms the variables using log transformation.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.LogTransformer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/log.html#LogTransformer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.LogTransformer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn parameters.</p>
<p>Select the numerical variables and determines whether the logarithm
can be applied on the selected variables (it checks if the variables
are all positive).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values
    - If some variables contain zero or negative values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.LogTransformer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/log.html#LogTransformer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.LogTransformer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Transforms the variables using log transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values.
    - If the dataframe not of the same size as that used in fit().
    - If some variables contains zero or negative values.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.MathematicalCombination">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">MathematicalCombination</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables_to_combine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">math_operations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_variables_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/creation/mathematical_combination.html#MathematicalCombination"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MathematicalCombination" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.base.TransformerMixin</span></code></p>
<p>MathematicalCombination() applies basic mathematical operations to multiple
features, returning one or more additional features as a result. That is, it sums,
multiplies, takes the average, maximum, minimum or standard deviation of a group
of variables and returns the result into new variables.</p>
<p>For example, if we have the variables <strong>number_payments_first_quarter</strong>,
<strong>number_payments_second_quarter</strong>, <strong>number_payments_third_quarter</strong> and
<strong>number_payments_fourth_quarter</strong>, we can use MathematicalCombination() to
calculate the total number of payments and mean number of payments as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">transformer</span> <span class="o">=</span> <span class="n">MathematicalCombination</span><span class="p">(</span>
    <span class="n">variables_to_combine</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;number_payments_first_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;number_payments_second_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;number_payments_third_quarter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;number_payments_fourth_quarter&#39;</span>
    <span class="p">],</span>
    <span class="n">math_operations</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mean&#39;</span>
    <span class="p">],</span>
    <span class="n">new_variables_name</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;total_number_payments&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mean_number_payments&#39;</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">Xt</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The transformed X, Xt, will contain the additional features
<strong>total_number_payments</strong> and <strong>mean_number_payments</strong>, plus the original set of
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables_to_combine</strong> (<em>list</em>) ‚Äì The list of numerical variables to be combined.</p></li>
<li><p><strong>math_operations</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì <p>The list of basic math operations to be used to create the new features.</p>
<p>If None, all of [‚Äòsum‚Äô, ‚Äòprod‚Äô, ‚Äòmean‚Äô, ‚Äòstd‚Äô, ‚Äòmax‚Äô, ‚Äòmin‚Äô] will be performed
over the <cite>variables_to_combine</cite>. Alternatively, the user can enter the list of
operations to carry out.</p>
<p>Each operation should be a string and must be one of the elements
from the list: [‚Äòsum‚Äô, ‚Äòprod‚Äô, ‚Äòmean‚Äô, ‚Äòstd‚Äô, ‚Äòmax‚Äô, ‚Äòmin‚Äô]</p>
<p>Each operation will result in a new variable that will be added to the
transformed dataset.</p>
</p></li>
<li><p><strong>new_variables_names</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì <p>Names of the newly created variables. The user can enter a name or a list
of names for the newly created features (recommended). The user must enter
one name for each mathematical transformation indicated in the <cite>math_operations</cite>
parameter. That is, if you want to perform mean and sum of features, you
should enter 2 new variable names. If you perform only mean of features,
enter 1 variable name. Alternatively, if you chose to perform all
mathematical transformations, enter 6 new variable names.</p>
<p>The name of the variables indicated by the user should coincide with the order
in which the mathematical operations are initialised in the transformer.
That is, if you set math_operations = [‚Äòmean‚Äô, ‚Äòprod‚Äô], the first new variable
name will be assigned to the mean of the variables and the second variable name
to the product of the variables.</p>
<p>If <cite>new_variable_names = None</cite>, the transformer will assign an arbitrary name
to the newly created features starting by the name of the mathematical
operation, followed by the variables combined separated by -.</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.MathematicalCombination.combination_dict_">
<code class="sig-name descname"><span class="pre">combination_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.MathematicalCombination.combination_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary containing the mathematical operation to column name pairs</p>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.feature_engine.MathematicalCombination.math_operations_">
<code class="sig-name descname"><span class="pre">math_operations_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.MathematicalCombination.math_operations_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>List with the mathematical operations to be applied to the
<cite>variables_to_combine</cite>.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn parameters.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Combine the variables with the mathematical operations.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>Although the transformer in essence allows us to combine any feature with any of
the allowed mathematical operations, its used is intended mostly for the creation
of new features based on some domain knowledge. Typical examples within the
financial sector are:</p>
<ul class="simple">
<li><p>Sum debt across financial products, i.e., credit cards, to obtain the total debt.</p></li>
<li><p>Take the average payments to various financial products per month.</p></li>
<li><p>Find the Minimum payment done at any one month.</p></li>
</ul>
<p>In insurance, we can sum the damage to various parts of a car to obtain the
total damage.</p>
<dl class="py method">
<dt id="ballet.eng.feature_engine.MathematicalCombination.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/creation/mathematical_combination.html#MathematicalCombination.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MathematicalCombination.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn parameters.</p>
<p>Perform dataframe checks. Creates dictionary of operation to new feature
name pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, or </em><em>np.array. Defaults to None.</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any user provided variables in variables_to_combine are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the variable(s) contain null values</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.MathematicalCombination.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/creation/mathematical_combination.html#MathematicalCombination.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MathematicalCombination.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Combine the variables with the mathematical operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of the same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the original variables plus the new variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Pandas dataframe, shape = [n_samples, n_features + n_operations]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.MeanEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">MeanEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/mean_encoding.html#MeanEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The MeanEncoder() replaces categories by the mean value of the target for each
category.</p>
<p>For example in the variable colour, if the mean of the target for blue, red
and grey is 0.5, 0.8 and 0.1 respectively, blue is replaced by 0.5, red by 0.8
and grey by 0.1.</p>
<p>The encoder will encode only categorical variables (type ‚Äòobject‚Äô). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first maps the categories to the numbers for each variable (fit). The
encoder then replaces the categories with the mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of categorical variables to encode. If None, the encoder will find and
select all object type variables.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.MeanEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.MeanEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the target mean value per category per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the target mean value per category, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Encode the categories to numbers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">inverse_transform:</span></code></dt>
<dd><p>Encode the numbers into the original categories.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>NAN are introduced when encoding categories that were not present in the training
dataset. If this happens, try grouping infrequent categories using the
RareLabelEncoder().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.encoding.RareLabelEncoder</span></code></p>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">1</span></dt>
<dd><p>Micci-Barreca D. ‚ÄúA Preprocessing Scheme for High-Cardinality Categorical
Attributes in Classification and Prediction Problems‚Äù. ACM SIGKDD Explorations
Newsletter, 2001. <a class="reference external" href="https://dl.acm.org/citation.cfm?id=507538">https://dl.acm.org/citation.cfm?id=507538</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.MeanEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/mean_encoding.html#MeanEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the mean value of the target for each category of the variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to be encoded.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em>) ‚Äì The target.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.MeanEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/mean_encoding.html#MeanEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Convert the encoded variable back to the original values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The transformed dataframe.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The un-transformed dataframe, with the categorical variables containing the
original values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.MeanEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/mean_encoding.html#MeanEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The dataset to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If after encoding, NAN were introduced.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe containing the categories replaced by numbers.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.MeanMedianImputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">MeanMedianImputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imputation_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/mean_median.html#MeanMedianImputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanMedianImputer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>The MeanMedianImputer() replaces missing data by the mean or median value of the
variable. It works only with numerical variables.</p>
<p>We can pass a list of variables to be imputed. Alternatively, the
MeanMedianImputer() will automatically select all variables of type numeric in the
training set.</p>
<p>The imputer:</p>
<ul class="simple">
<li><p>first calculates the mean / median values of the variables (fit).</p></li>
<li><p>Then replaces the missing data with the estimated mean / median (transform).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imputation_method</strong> (<em>str</em><em>, </em><em>default=median</em>) ‚Äì Desired method of imputation. Can take ‚Äòmean‚Äô or ‚Äòmedian‚Äô.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will select
all variables of type numeric.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.MeanMedianImputer.imputer_dict_">
<code class="sig-name descname"><span class="pre">imputer_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.MeanMedianImputer.imputer_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the mean or median values per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the mean or median values.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Impute missing data.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.MeanMedianImputer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/mean_median.html#MeanMedianImputer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanMedianImputer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the mean or median values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em><em> or </em><em>None</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì If there are no numerical variables in the df or the df is empty</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.MeanMedianImputer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/mean_median.html#MeanMedianImputer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.MeanMedianImputer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace missing data with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe without missing values in the selected variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.OneHotEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">OneHotEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">top_categories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/one_hot.html#OneHotEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OneHotEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>One hot encoding consists in replacing the categorical variable by a
combination of binary variables which take value 0 or 1, to indicate if
a certain category is present in an observation. The binary variables are also
known as dummy variables.</p>
<p>For example, from the categorical variable ‚ÄúGender‚Äù with categories ‚Äúfemale‚Äù and
‚Äúmale‚Äù, we can generate the boolean variable ‚Äúfemale‚Äù, which takes 1 if the
observation is female or 0 otherwise. We can also generate the variable ‚Äúmale‚Äù,
which takes 1 if the observation is ‚Äúmale‚Äù and 0 otherwise.</p>
<p>The encoder can create k binary variables per categorical variable, k being the
number of unique categories, or alternatively k-1 to avoid redundant information.
This behaviour can be specified using the parameter <cite>drop_last</cite>.</p>
<p>The encoder has the additional option to generate binary variables only for the
top n most popular categories, that is, the categories that are shared by the
majority of the observations in the dataset. This behaviour can be specified with
the parameter <cite>top_categories</cite>.</p>
<p><strong>Note</strong></p>
<p>Only when creating binary variables for all categories of the variable, we
can specify if we want to encode into k or k-1 binary variables, where k is the
number if unique categories. If we encode only the top n most popular categories,
the encoder will create only n binary variables per categorical variable.
Observations that do not show any of these popular categories, will have 0 in all
the binary variables.</p>
<p>The encoder will encode only categorical variables (type ‚Äòobject‚Äô). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode categorical variables (object type).</p>
<p>The encoder first finds the categories to be encoded for each variable (fit). The
encoder then creates one dummy variable per category for each variable
(transform).</p>
<p><strong>Note</strong></p>
<p>New categories in the data to transform, that is, those that did not appear
in the training set, will be ignored (no binary variable will be created for them).
This means that observations with categories not present in the train set, will be
encoded as 0 in all the binary variables.</p>
<p><strong>Also Note</strong></p>
<p>The original categorical variables are removed from the returned dataset when we
apply the transform() method. In their place, the binary variables are returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>top_categories</strong> (<em>int</em><em>, </em><em>default=None</em>) ‚Äì If None, a dummy variable will be created for each category of the variable.
Alternatively, we can indicate in <cite>top_categories</cite> the number of most frequent
categories to encode. In this case, dummy variables will be created only for
those popular categories and the rest will be ignored, i.e., they will show the
value 0 in all the binary variables.</p></li>
<li><p><strong>variables</strong> (<em>list</em>) ‚Äì The list of categorical variables to encode. If None, the encoder will find and
select all object type variables in the train set.</p></li>
<li><p><strong>drop_last</strong> (<em>boolean</em><em>, </em><em>default=False</em>) ‚Äì Only used if <cite>top_categories = None</cite>. It indicates whether to create dummy
variables for all the categories (k dummies), or if set to <cite>True</cite>, it will
ignore the last binary variable of the list (k-1 dummies).</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.OneHotEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.OneHotEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the categories for which dummy variables will be created.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the unique categories per variable</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Replace the categorical variables by the binary variables.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>If the variables are intended for linear models, it is recommended to encode into
k-1 or top categories. If the variables are intended for tree based algorithms,
it is recommended to encode into k or top n categories. If feature selection
will be performed, then also encode into k or top n categories. Linear models
evaluate all features during fit, while tree based models and many feature
selection algorithms evaluate variables or groups of variables separately. Thus, if
encoding into k-1, the last variable / category will not be examined.</p>
<p class="rubric">References</p>
<p>One hot encoding of top categories was described in the following article:</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">1</span></dt>
<dd><p>Niculescu-Mizil, et al. ‚ÄúWinning the KDD Cup Orange Challenge with Ensemble
Selection‚Äù. JMLR: Workshop and Conference Proceedings 7: 23-34. KDD 2009
<a class="reference external" href="http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf">http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.OneHotEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/one_hot.html#OneHotEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OneHotEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learns the unique categories per variable. If top_categories is indicated,
it will learn the most popular categories. Alternatively, it learns all
unique categories per variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples.
Can be the entire dataframe, not just seleted variables.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em><em>, </em><em>default=None</em>) ‚Äì Target. It is not needed in this encoded. You can pass y or
None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.OneHotEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/one_hot.html#OneHotEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OneHotEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>inverse_transform is not implemented for this transformer.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.OneHotEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/one_hot.html#OneHotEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OneHotEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replaces the categorical variables by the binary variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values.
    - If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The transformed dataframe. The shape of the dataframe will be different from
the original as it includes the dummy variables in place of the of the
original categorical ones.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.OrdinalEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">OrdinalEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ordered'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/ordinal.html#OrdinalEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OrdinalEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The OrdinalCategoricalEncoder() replaces categories by ordinal numbers
(0, 1, 2, 3, etc). The numbers can be ordered based on the mean of the target
per category, or assigned arbitrarily.</p>
<p><strong>Ordered ordinal encoding</strong>: for the variable colour, if the mean of the target
for blue, red and grey is 0.5, 0.8 and 0.1 respectively, blue is replaced by 1,
red by 2 and grey by 0.</p>
<p><strong>Arbitrary ordinal encoding</strong>: the numbers will be assigned arbitrarily to the
categories, on a first seen first served basis.</p>
<p>The encoder will encode only categorical variables (type ‚Äòobject‚Äô). A list
of variables can be passed as an argument. If no variables are passed, the
encoder will find and encode all categorical variables (type ‚Äòobject‚Äô).</p>
<p>The encoder first maps the categories to the numbers for each variable (fit). The
encoder then transforms the categories to the mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default='ordered'</em>) ‚Äì <p>Desired method of encoding.</p>
<p>‚Äôordered‚Äô: the categories are numbered in ascending order according to
the target mean value per category.</p>
<p>‚Äôarbitrary‚Äô : categories are numbered arbitrarily.</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.OrdinalEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.OrdinalEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the ordinal number per category, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Find the integer to replace each category in each variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Encode the categories to numbers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">inverse_transform:</span></code></dt>
<dd><p>Encode the numbers into the original categories.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>NAN are introduced when encoding categories that were not present in the training
dataset. If this happens, try grouping infrequent categories using the
RareLabelEncoder().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.encoding.RareLabelEncoder</span></code></p>
</div>
<p class="rubric">References</p>
<p>Encoding into integers ordered following target mean was discussed in the following
talk at PyData London 2017:</p>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets">1</span></dt>
<dd><p>Galli S. ‚ÄúMachine Learning in Financial Risk Assessment‚Äù.
<a class="reference external" href="https://www.youtube.com/watch?v=KHGGlozsRtA">https://www.youtube.com/watch?v=KHGGlozsRtA</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.OrdinalEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/ordinal.html#OrdinalEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OrdinalEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the numbers to be used to replace the categories in each
variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to be encoded.</p></li>
<li><p><strong>y</strong> (<em>pandas series</em><em>, </em><em>default=None</em>) ‚Äì The Target. Can be None if encoding_method = ‚Äòarbitrary‚Äô.
Otherwise, y needs to be passed when fitting the transformer.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.OrdinalEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/ordinal.html#OrdinalEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OrdinalEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Convert the encoded variable back to the original values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The transformed dataframe.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The un-transformed dataframe, with the categorical variables containing the
original values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.OrdinalEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/ordinal.html#OrdinalEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OrdinalEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The dataset to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If after encoding, NAN were introduced.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe containing the categories replaced by numbers.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.OutlierTrimmer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">OutlierTrimmer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capping_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'right'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/trimmer.html#OutlierTrimmer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OutlierTrimmer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.outliers.winsorizer.Winsorizer</span></code></p>
<p>The OutlierTrimmer() removes observations with outliers from the dataset.</p>
<p>It works only with numerical variables. A list of variables can be indicated.
Alternatively, the OutlierTrimmer() will select all numerical variables.</p>
<p>The OutlierTrimmer() first calculates the maximum and /or minimum values
beyond which a value will be considered an outlier, and thus removed.</p>
<p>Limits are determined using:</p>
<ul class="simple">
<li><p>a Gaussian approximation</p></li>
<li><p>the inter-quantile range proximity rule</p></li>
<li><p>percentiles.</p></li>
</ul>
<p><strong>Gaussian limits:</strong></p>
<ul class="simple">
<li><p>right tail: mean + 3* std</p></li>
<li><p>left tail: mean - 3* std</p></li>
</ul>
<p><strong>IQR limits:</strong></p>
<ul class="simple">
<li><p>right tail: 75th quantile + 3* IQR</p></li>
<li><p>left tail:  25th quantile - 3* IQR</p></li>
</ul>
<p>where IQR is the inter-quartile range: 75th quantile - 25th quantile.</p>
<p><strong>percentiles or quantiles:</strong></p>
<ul class="simple">
<li><p>right tail: 95th percentile</p></li>
<li><p>left tail:  5th percentile</p></li>
</ul>
<p>You can select how far out to cap the maximum or minimum values with the
parameter ‚Äòfold‚Äô.</p>
<p>If <cite>capping_method=‚Äôgaussian‚Äô</cite> fold gives the value to multiply the std.</p>
<p>If <cite>capping_method=‚Äôiqr‚Äô</cite> fold is the value to multiply the IQR.</p>
<p>If <cite>capping_method=‚Äôquantile‚Äô</cite>, fold is the percentile on each tail that should
be censored. For example, if fold=0.05, the limits will be the 5th and 95th
percentiles. If fold=0.1, the limits will be the 10th and 90th percentiles.</p>
<p>The transformer first finds the values at one or both tails of the distributions
(fit).</p>
<p>The transformer then removes observations with outliers from the dataframe
(transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>capping_method</strong> (<em>str</em><em>, </em><em>default=gaussian</em>) ‚Äì <p>Desired capping method. Can take ‚Äògaussian‚Äô, ‚Äòiqr‚Äô or ‚Äòquantiles‚Äô.</p>
<p>‚Äôgaussian‚Äô: the transformer will find the maximum and / or minimum values to
cap the variables using the Gaussian approximation.</p>
<p>‚Äôiqr‚Äô: the transformer will find the boundaries using the IQR proximity rule.</p>
<p>‚Äôquantiles‚Äô: the limits are given by the percentiles.</p>
</p></li>
<li><p><strong>tail</strong> (<em>str</em><em>, </em><em>default=right</em>) ‚Äì Whether to cap outliers on the right, left or both tails of the distribution.
Can take ‚Äòleft‚Äô, ‚Äòright‚Äô or ‚Äòboth‚Äô.</p></li>
<li><p><strong>fold</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>default=3</em>) ‚Äì <p>How far out to to place the capping values. The number that will multiply
the std or IQR to calculate the capping values. Recommended values, 2
or 3 for the gaussian approximation, or 1.5 or 3 for the IQR proximity
rule.</p>
<p>If capping_method=‚Äôquantile‚Äô, then ‚Äòfold‚Äô indicates the percentile. So if
fold=0.05, the limits will be the 95th and 5th percentiles.
<strong>Note</strong>: Outliers will be removed up to a maximum of the 20th percentiles on
both sides. Thus, when capping_method=‚Äôquantile‚Äô, then ‚Äòfold‚Äô takes values
between 0 and 0.20.</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables for which the outliers will be removed If None,
the transformer will find and select all numerical variables.</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='raise'</em>) ‚Äì Indicates if missing values should be ignored or raised. Sometimes we want to
remove outliers in the raw, original data, sometimes, we may want to remove
outliers in the already pre-transformed data. If missing_values=‚Äôignore‚Äô, the
transformer will ignore missing data when learning the capping parameters or
transforming the data. If missing_values=‚Äôraise‚Äô the transformer will return
an error if the training or the datasets to transform contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.OutlierTrimmer.right_tail_caps_">
<code class="sig-name descname"><span class="pre">right_tail_caps_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.OutlierTrimmer.right_tail_caps_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the maximum values above which values will be removed</p>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.feature_engine.OutlierTrimmer.left_tail_caps_">
<code class="sig-name descname"><span class="pre">left_tail_caps_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.OutlierTrimmer.left_tail_caps_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the minimum values below which values will be removed</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Find maximum and minimum values.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Remove outliers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data. Then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.OutlierTrimmer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/trimmer.html#OutlierTrimmer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.OutlierTrimmer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Remove observations with outliers from the dataframe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe without outlier observations.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.PRatioEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">PRatioEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ratio'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/probability_ratio.html#PRatioEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PRatioEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The PRatioEncoder() replaces categories by the ratio of the probability of the
target = 1 and the probability of the target = 0.</p>
<p>The target probability ratio is given by:</p>
<div class="math notranslate nohighlight">
\[p(1) / p(0)\]</div>
<p>The log of the target probability ratio is:</p>
<div class="math notranslate nohighlight">
\[log( p(1) / p(0) )\]</div>
<p><strong>Note</strong></p>
<p>This categorical encoding is exclusive for binary classification.</p>
<p>For example in the variable colour, if the mean of the target = 1 for blue
is 0.8 and the mean of the target = 0  is 0.2, blue will be replaced by:
0.8 / 0.2 = 4 if ratio is selected, or log(0.8/0.2) = 1.386 if log_ratio
is selected.</p>
<p>Note: the division by 0 is not defined and the log(0) is not defined.
Thus, if p(0) = 0 for the ratio encoder, or either p(0) = 0 or p(1) = 0 for
log_ratio, in any of the variables, the encoder will return an error.</p>
<p>The encoder will encode only categorical variables (type ‚Äòobject‚Äô). A list
of variables can be passed as an argument. If no variables are passed the encoder
will find and encode all categorical variables (object type).</p>
<p>The encoder first maps the categories to the numbers for each variable (fit). The
encoder then transforms the categories into the mapped numbers (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoding_method</strong> (<em>str</em><em>, </em><em>default=woe</em>) ‚Äì <p>Desired method of encoding.</p>
<p>‚Äôratio‚Äô : probability ratio</p>
<p>‚Äôlog_ratio‚Äô : log probability ratio</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of categorical variables to encode. If None, the encoder will find and
select all object type variables.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.PRatioEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.PRatioEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the probability ratio per category per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn probability ratio per category, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Encode categories into numbers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">inverse_transform:</span></code></dt>
<dd><p>Encode the numbers into the original categories.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>NAN are introduced when encoding categories that were not present in the training
dataset. If this happens, try grouping infrequent categories using the
RareLabelEncoder().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.encoding.RareLabelEncoder</span></code></p>
</div>
<dl class="py method">
<dt id="ballet.eng.feature_engine.PRatioEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/probability_ratio.html#PRatioEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PRatioEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the numbers that should be used to replace the categories in each
variable. That is the ratio of probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
categorical variables.</p></li>
<li><p><strong>y</strong> (<em>pandas series.</em>) ‚Äì Target, must be binary [0,1].</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not the Pandas DataFrame.
    - If any user provided variables are not categorical.</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in df or df is empty
    - If variable(s) contain null values.
    - If y is not binary with values 0 and 1.
    - If p(0) = 0 or any of p(0) or p(1) are 0.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.PRatioEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/probability_ratio.html#PRatioEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PRatioEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Convert the encoded variable back to the original values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The transformed dataframe.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The un-transformed dataframe, with the categorical variables containing the
original values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.PRatioEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/probability_ratio.html#PRatioEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PRatioEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The dataset to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If after encoding, NAN were introduced.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe containing the categories replaced by numbers.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.PowerTransformer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">PowerTransformer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/power.html#PowerTransformer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PowerTransformer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The PowerTransformer() applies power or exponential transformations to
numerical variables.</p>
<p>The PowerTransformer() works only with numerical variables.</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p></li>
<li><p><strong>exp</strong> (<em>float</em><em> or </em><em>int</em><em>, </em><em>default=0.5</em>) ‚Äì The power (or exponent).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn parameters.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Apply the power transformation to the variables.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.PowerTransformer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/power.html#PowerTransformer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PowerTransformer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples.
Can be the entire dataframe, not just the variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.PowerTransformer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/power.html#PowerTransformer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.PowerTransformer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Apply the power transformation to the variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values.
    - If the dataframe not of the same size as that used in fit().</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the power transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas Dataframe</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.RandomSampleImputer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">RandomSampleImputer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'general'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeding_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'add'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/random_sample.html#RandomSampleImputer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RandomSampleImputer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.imputation.base_imputer.BaseImputer</span></code></p>
<p>The RandomSampleImputer() replaces missing data in each feature with a random
sample extracted from the variables in the training set.
The RandomSampleImputer() works with both numerical and categorical variables.</p>
<p><strong>Note</strong></p>
<p>Random samples will vary from execution to execution. This may affect
the results of your work. Remember to set a seed before running the
RandomSampleImputer().</p>
<p>There are 2 ways in which the seed can be set with the RandomSampleImputer():</p>
<p>If seed = ‚Äògeneral‚Äô then the random_state can be either None or an integer.
The seed will be used as the random_state and all observations will be
imputed in one go. This is equivalent to <cite>pandas.sample(n, random_state=seed)</cite>
where n is the number of observations with missing data.</p>
<p>If seed = ‚Äòobservation‚Äô, then the random_state should be a variable name
or a list of variable names. The seed will be calculated observation per
observation, either by adding or multiplying the seeding variable values, and
passed to the random_state. Then, a value will be extracted from the train set
using that seed and  used to replace the NAN in particular observation. This is the
equivalent of <cite>pandas.sample(1, random_state=var1+var2)</cite> if the ‚Äòseeding_method‚Äô is
set to ‚Äòadd‚Äô or <cite>pandas.sample(1, random_state=var1*var2)</cite> if the ‚Äòseeding_method‚Äô
is set to ‚Äòmultiply‚Äô.</p>
<p>For more details on why this functionality is important refer to the course
Feature Engineering for Machine Learning in Udemy:
<a class="reference external" href="https://www.udemy.com/feature-engineering-for-machine-learning/">https://www.udemy.com/feature-engineering-for-machine-learning/</a></p>
<p>Note, if the variables indicated in the random_state list are not numerical
the imputer will return an error. Note also that the variables indicated as seed
should not contain missing values.</p>
<p>This estimator stores a copy of the training set when the fit() method is
called. Therefore, the object can become quite heavy. Also, it may not be GDPR
compliant if your training data set contains Personal Information. Please check
if this behaviour is allowed within your organisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>random_state</strong> (<em>int</em><em>, </em><em>str</em><em> or </em><em>list</em><em>, </em><em>default=None</em>) ‚Äì The random_state can take an integer to set the seed when extracting the
random samples. Alternatively, it can take a variable name or a list of
variables, which values will be used to determine the seed observation per
observation.</p></li>
<li><p><strong>seed</strong> (<em>str</em><em>, </em><em>default='general'</em>) ‚Äì <p>Indicates whether the seed should be set for each observation with missing
values, or if one seed should be used to impute all variables in one go.</p>
<p><strong>general</strong>: one seed will be used to impute the entire dataframe. This is
equivalent to setting the seed in pandas.sample(random_state).</p>
<p><strong>observation</strong>: the seed will be set for each observation using the values
of the variables indicated in the random_state for that particular
observation.</p>
</p></li>
<li><p><strong>seeding_method</strong> (<em>str</em><em>, </em><em>default='add'</em>) ‚Äì If more than one variable are indicated to seed the random sampling per
observation, you can choose to combine those values as an addition or a
multiplication. Can take the values ‚Äòadd‚Äô or ‚Äòmultiply‚Äô.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables to be imputed. If None, the imputer will select
all variables in the train set.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.RandomSampleImputer.X_">
<code class="sig-name descname"><span class="pre">X_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.RandomSampleImputer.X_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Copy of the training dataframe from which to extract the random samples.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Make a copy of the dataframe</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Impute missing data.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.RandomSampleImputer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/random_sample.html#RandomSampleImputer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RandomSampleImputer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Makes a copy of the train set. Only stores a copy of the variables to impute.
This copy is then used to randomly extract the values to fill the missing data
during transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training dataset. Only a copy of the indicated variables will be stored
in the transformer.</p></li>
<li><p><strong>y</strong> (<em>None</em>) ‚Äì y is not needed in this imputation. You can pass None or y.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.RandomSampleImputer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/imputation/random_sample.html#RandomSampleImputer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RandomSampleImputer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace missing data with random values taken from the train set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The dataframe to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe without missing values in the transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.RareLabelEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">RareLabelEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_categories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n_categories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Rare'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/rare_label.html#RareLabelEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RareLabelEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The RareLabelCategoricalEncoder() groups rare / infrequent categories in
a new category called ‚ÄúRare‚Äù, or any other name entered by the user.</p>
<p>For example in the variable colour, if the percentage of observations
for the categories magenta, cyan and burgundy are &lt; 5 %, all those
categories will be replaced by the new label ‚ÄúRare‚Äù.</p>
<p><strong>Note</strong></p>
<p>Infrequent labels can also be grouped under a user defined name, for
example ‚ÄòOther‚Äô. The name to replace infrequent categories is defined
with the parameter <cite>replace_with</cite>.</p>
<p>The encoder will encode only categorical variables (type ‚Äòobject‚Äô). A list
of variables can be passed as an argument. If no variables are passed as
argument, the encoder will find and encode all categorical variables
(object type).</p>
<p>The encoder first finds the frequent labels for each variable (fit). The encoder
then groups the infrequent labels under the new label ‚ÄòRare‚Äô or by another user
defined string (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>default=0.05</em>) ‚Äì The minimum frequency a label should have to be considered frequent.
Categories with frequencies lower than tol will be grouped.</p></li>
<li><p><strong>n_categories</strong> (<em>int</em><em>, </em><em>default=10</em>) ‚Äì The minimum number of categories a variable should have for the encoder
to find frequent labels. If the variable contains less categories, all
of them will be considered frequent.</p></li>
<li><p><strong>max_n_categories</strong> (<em>int</em><em>, </em><em>default=None</em>) ‚Äì The maximum number of categories that should be considered frequent.
If None, all categories with frequency above the tolerance (tol) will be
considered frequent.</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of categorical variables to encode. If None, the encoder will
find and select all object type variables.</p></li>
<li><p><strong>replace_with</strong> (<em>string</em><em>, </em><em>default='Rare'</em>) ‚Äì The category name that will be used to replace infrequent categories.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.RareLabelEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.RareLabelEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the frequent categories, i.e.., those that will be
kept, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Find frequent categories.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Group rare categories</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.RareLabelEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/rare_label.html#RareLabelEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RareLabelEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the frequent categories for each variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just selected
variables</p></li>
<li><p><strong>y</strong> (<em>None</em>) ‚Äì y is not required. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame.
    - If any user provided variable is not categorical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in the df or the df is empty
    - If the variable(s) contain null values</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If the number of categories in any one variable is less than the indicated
    in <cite>n_categories</cite>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.RareLabelEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/rare_label.html#RareLabelEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RareLabelEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>inverse_transform is not implemented for this transformer yet.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.RareLabelEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/rare_label.html#RareLabelEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.RareLabelEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Group infrequent categories. Replace infrequent categories by the string ‚ÄòRare‚Äô
or any other name provided by the user.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The input samples.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe where rare categories have been grouped.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.ReciprocalTransformer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">ReciprocalTransformer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/reciprocal.html#ReciprocalTransformer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ReciprocalTransformer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The ReciprocalTransformer() applies the reciprocal transformation 1 / x
to numerical variables.</p>
<p>The ReciprocalTransformer() only works with numerical variables with non-zero
values. If a variable contains the value 0, the transformer will raise an error.</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p>
</dd>
</dl>
<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>This transformer does not learn parameters.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Apply the reciprocal 1 / x transformation.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.ReciprocalTransformer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/reciprocal.html#ReciprocalTransformer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ReciprocalTransformer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>This transformer does not learn parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no numerical variables in the df or the df is empty
    - If the variable(s) contain null values
    - If some variables contain zero as values</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.ReciprocalTransformer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/reciprocal.html#ReciprocalTransformer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.ReciprocalTransformer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Apply the reciprocal 1 / x transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values.
    - If the dataframe not of the same size as that used in fit().
    - If some variables contain zero values.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.Winsorizer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">Winsorizer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capping_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'right'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">missing_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/winsorizer.html#Winsorizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.Winsorizer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.outliers.base_outlier.BaseOutlier</span></code></p>
<p>The Winsorizer() caps maximum and / or minimum values of a variable.</p>
<p>The Winsorizer() works only with numerical variables. A list of variables can
be indicated. Alternatively, the Winsorizer() will select all numerical
variables in the train set.</p>
<p>The Winsorizer() first calculates the capping values at the end of the
distribution. The values are determined using:</p>
<ul class="simple">
<li><p>a Gaussian approximation,</p></li>
<li><p>the inter-quantile range proximity rule (IQR)</p></li>
<li><p>percentiles.</p></li>
</ul>
<p><strong>Gaussian limits:</strong></p>
<ul class="simple">
<li><p>right tail: mean + 3* std</p></li>
<li><p>left tail: mean - 3* std</p></li>
</ul>
<p><strong>IQR limits:</strong></p>
<ul class="simple">
<li><p>right tail: 75th quantile + 3* IQR</p></li>
<li><p>left tail:  25th quantile - 3* IQR</p></li>
</ul>
<p>where IQR is the inter-quartile range: 75th quantile - 25th quantile.</p>
<p><strong>percentiles or quantiles:</strong></p>
<ul class="simple">
<li><p>right tail: 95th percentile</p></li>
<li><p>left tail:  5th percentile</p></li>
</ul>
<p>You can select how far out to cap the maximum or minimum values with the
parameter ‚Äòfold‚Äô.</p>
<p>If <cite>capping_method=‚Äôgaussian‚Äô</cite> fold gives the value to multiply the std.</p>
<p>If <cite>capping_method=‚Äôiqr‚Äô</cite> fold is the value to multiply the IQR.</p>
<p>If <cite>capping_method=‚Äôquantile‚Äô</cite>, fold is the percentile on each tail that should
be censored. For example, if fold=0.05, the limits will be the 5th and 95th
percentiles. If fold=0.1, the limits will be the 10th and 90th percentiles.</p>
<p>The transformer first finds the values at one or both tails of the distributions
(fit). The transformer then caps the variables (transform).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>capping_method</strong> (<em>str</em><em>, </em><em>default=gaussian</em>) ‚Äì <p>Desired capping method. Can take ‚Äògaussian‚Äô, ‚Äòiqr‚Äô or ‚Äòquantiles‚Äô.</p>
<p>‚Äôgaussian‚Äô: the transformer will find the maximum and / or minimum values to
cap the variables using the Gaussian approximation.</p>
<p>‚Äôiqr‚Äô: the transformer will find the boundaries using the IQR proximity rule.</p>
<p>‚Äôquantiles‚Äô: the limits are given by the percentiles.</p>
</p></li>
<li><p><strong>tail</strong> (<em>str</em><em>, </em><em>default=right</em>) ‚Äì Whether to cap outliers on the right, left or both tails of the distribution.
Can take ‚Äòleft‚Äô, ‚Äòright‚Äô or ‚Äòboth‚Äô.</p></li>
<li><p><strong>fold</strong> (<em>int</em><em> or </em><em>float</em><em>, </em><em>default=3</em>) ‚Äì <p>How far out to to place the capping values. The number that will multiply
the std or IQR to calculate the capping values. Recommended values, 2
or 3 for the gaussian approximation, or 1.5 or 3 for the IQR proximity
rule.</p>
<p>If capping_method=‚Äôquantile‚Äô, then ‚Äòfold‚Äô indicates the percentile. So if
fold=0.05, the limits will be the 95th and 5th percentiles.
<strong>Note</strong>: Outliers will be removed up to a maximum of the 20th percentiles on
both sides. Thus, when capping_method=‚Äôquantile‚Äô, then ‚Äòfold‚Äô takes values
between 0 and 0.20.</p>
</p></li>
<li><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of variables for which the outliers will be capped. If None,
the transformer will find and select all numerical variables.</p></li>
<li><p><strong>missing_values</strong> (<em>string</em><em>, </em><em>default='raise'</em>) ‚Äì Indicates if missing values should be ignored or raised. Sometimes we want to
remove outliers in the raw, original data, sometimes, we may want to remove
outliers in the already pre-transformed data. If missing_values=‚Äôignore‚Äô, the
transformer will ignore missing data when learning the capping parameters or
transforming the data. If missing_values=‚Äôraise‚Äô the transformer will return
an error if the training or the datasets to transform contain missing values.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.Winsorizer.right_tail_caps_">
<code class="sig-name descname"><span class="pre">right_tail_caps_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.Winsorizer.right_tail_caps_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the maximum values at which variables will be capped.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ballet.eng.feature_engine.Winsorizer.left_tail_caps_">
<code class="sig-name descname"><span class="pre">left_tail_caps_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.Winsorizer.left_tail_caps_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the minimum values at which variables will be capped.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the values that should be used to replace outliers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Cap the variables.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data. Then transform it.</p>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.Winsorizer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/winsorizer.html#Winsorizer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.Winsorizer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the values that should be used to replace outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì y is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.Winsorizer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/outliers/winsorizer.html#Winsorizer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.Winsorizer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Cap the variable values, that is, censors outliers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the capped variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.WoEEncoder">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">WoEEncoder</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/woe.html#WoEEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.WoEEncoder" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.encoding.base_encoder.BaseCategoricalTransformer</span></code></p>
<p>The WoERatioCategoricalEncoder() replaces categories by the weight of evidence
(WoE). The WoE was used primarily in the financial sector to create credit risk
scorecards.</p>
<p>The encoder will encode only categorical variables (type ‚Äòobject‚Äô). A list
of variables can be passed as an argument. If no variables are passed the encoder
will find and encode all categorical variables (object type).</p>
<p>The encoder first maps the categories to the weight of evidence for each variable
(fit). The encoder then transforms the categories into the mapped numbers
(transform).</p>
<p><strong>Note</strong></p>
<p>This categorical encoding is exclusive for binary classification.</p>
<p><strong>The weight of evidence is given by:</strong></p>
<div class="math notranslate nohighlight">
\[log( p(X=xj|Y = 1) / p(X=xj|Y=0) )\]</div>
<p><strong>The WoE is determined as follows:</strong></p>
<p>We calculate the percentage positive cases in each category of the total of all
positive cases. For example 20 positive cases in category A out of 100 total
positive cases equals 20 %. Next, we calculate the percentage of negative cases in
each category respect to the total negative cases, for example 5 negative cases in
category A out of a total of 50 negative cases equals 10%. Then we calculate the
WoE by dividing the category percentages of positive cases by the category
percentage of negative cases, and take the logarithm, so for category A in our
example WoE = log(20/10).</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li><p>If WoE values are negative, negative cases supersede the positive cases.</p></li>
<li><p>If WoE values are positive, positive cases supersede the negative cases.</p></li>
<li><p>And if WoE is 0, then there are equal number of positive and negative examples.</p></li>
</ul>
<p><strong>Encoding into WoE</strong>:</p>
<ul class="simple">
<li><p>Creates a monotonic relationship between the encoded variable and the target</p></li>
<li><p>Returns variables in a similar scale</p></li>
</ul>
<p><strong>Note</strong></p>
<p>The log(0) is not defined and the division by 0 is not defined. Thus, if any of the
terms in the WoE equation are 0 for a given category, the encoder will return an
error. If this happens, try grouping less frequent categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of categorical variables that will be encoded. If None, the
encoder will find and select all object type variables.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.WoEEncoder.encoder_dict_">
<code class="sig-name descname"><span class="pre">encoder_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.WoEEncoder.encoder_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary with the WoE per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the WoE per category, per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Encode the categories to numbers.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to the data, then transform it.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">inverse_transform:</span></code></dt>
<dd><p>Encode the numbers into the original categories.</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>For details on the calculation of the weight of evidence visit:
<a class="reference external" href="https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html">https://www.listendata.com/2015/03/weight-of-evidence-woe-and-information.html</a></p>
<p>In credit scoring, continuous variables are also transformed using the WoE. To do
this, first variables are sorted into a discrete number of bins, and then these
bins are encoded with the WoE as explained here for categorical variables. You can
do this by combining the use of the equal width, equal frequency or arbitrary
discretisers.</p>
<p>NAN are introduced when encoding categories that were not present in the training
dataset. If this happens, try grouping infrequent categories using the
RareLabelEncoder().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.encoding.RareLabelEncoder</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">feature_engine.discretisation</span></code></p>
</div>
<dl class="py method">
<dt id="ballet.eng.feature_engine.WoEEncoder.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/woe.html#WoEEncoder.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.WoEEncoder.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the the WoE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples.
Can be the entire dataframe, not just the categorical variables.</p></li>
<li><p><strong>y</strong> (<em>pandas series.</em>) ‚Äì Target, must be binary [0,1].</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not the Pandas DataFrame.
    - If any user provided variables are not categorical.</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If there are no categorical variables in df or df is empty
    - If variable(s) contain null values.
    - If y is not binary with values 0 and 1.
    - If p(0) = 0 or p(1) = 0.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.WoEEncoder.inverse_transform">
<code class="sig-name descname"><span class="pre">inverse_transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/woe.html#WoEEncoder.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.WoEEncoder.inverse_transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Convert the encoded variable back to the original values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The transformed dataframe.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì <ul>
<li><p>If the input is not a Pandas DataFrame</p></li>
</ul>
</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If the dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The un-transformed dataframe, with the categorical variables containing the
original values.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.WoEEncoder.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/encoding/woe.html#WoEEncoder.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.WoEEncoder.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Replace categories with the learned parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em><em></em>) ‚Äì The dataset to transform.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values
    - If dataframe is not of same size as that used in fit()</p></li>
</ul>
</p></li>
<li><p><strong>Warning</strong> ‚Äì If after encoding, NAN were introduced.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe containing the categories replaced by numbers.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe of shape = [n_samples, n_features]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="ballet.eng.feature_engine.YeoJohnsonTransformer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">ballet.eng.feature_engine.</span></code><code class="sig-name descname"><span class="pre">YeoJohnsonTransformer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/yeojohnson.html#YeoJohnsonTransformer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.YeoJohnsonTransformer" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">feature_engine.base_transformers.BaseNumericalTransformer</span></code></p>
<p>The YeoJohnsonTransformer() applies the Yeo-Johnson transformation to the
numerical variables.</p>
<p>The Yeo-Johnson transformation implemented by this transformer is that of
SciPy.stats:
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html</a></p>
<p>The YeoJohnsonTransformer() works only with numerical variables.</p>
<p>A list of variables can be passed as an argument. Alternatively, the
transformer will automatically select and transform all numerical
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> (<em>list</em><em>, </em><em>default=None</em>) ‚Äì The list of numerical variables that will be transformed. If None, the
transformer will automatically find and select all numerical variables.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="ballet.eng.feature_engine.YeoJohnsonTransformer.lambda_dict_">
<code class="sig-name descname"><span class="pre">lambda_dict_</span></code><a class="headerlink" href="#ballet.eng.feature_engine.YeoJohnsonTransformer.lambda_dict_" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Dictionary containing the best lambda for the Yeo-Johnson per variable.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit:</span></code></dt>
<dd><p>Learn the optimal lambda for the Yeo-Johnson transformation.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">transform:</span></code></dt>
<dd><p>Apply the Yeo-Johnson transformation.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">fit_transform:</span></code></dt>
<dd><p>Fit to data, then transform it.</p>
</dd></dl>

<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets">1</span></dt>
<dd><p>Weisberg S. ‚ÄúYeo-Johnson Power Transformations‚Äù.
<a class="reference external" href="https://www.stat.umn.edu/arc/yjpower.pdf">https://www.stat.umn.edu/arc/yjpower.pdf</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="ballet.eng.feature_engine.YeoJohnsonTransformer.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/yeojohnson.html#YeoJohnsonTransformer.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.YeoJohnsonTransformer.fit" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Learn the optimal lambda for the Yeo-Johnson transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>pandas dataframe of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The training input samples. Can be the entire dataframe, not just the
variables to transform.</p></li>
<li><p><strong>y</strong> (<em>pandas Series</em><em>, </em><em>default=None</em>) ‚Äì It is not needed in this transformer. You can pass y or None.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>TypeError</strong> ‚Äì <ul class="simple">
<li><p>If the input is not a Pandas DataFrame
    - If any of the user provided variables are not numerical</p></li>
</ul>
</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><ul class="simple">
<li><p>If there are no numerical variables in the df or the df is empty</p></li>
<li><p>If the variable(s) contain null values</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ballet.eng.feature_engine.YeoJohnsonTransformer.transform">
<code class="sig-name descname"><span class="pre">transform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/feature_engine/transformation/yeojohnson.html#YeoJohnsonTransformer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ballet.eng.feature_engine.YeoJohnsonTransformer.transform" title="Permalink to this definition">¬∂</a></dt>
<dd><p>Apply the Yeo-Johnson transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Pandas DataFrame of shape =</em><em> [</em><em>n_samples</em><em>, </em><em>n_features</em><em>]</em>) ‚Äì The data to be transformed.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>TypeError</strong> ‚Äì If the input is not a Pandas DataFrame</p></li>
<li><p><strong>ValueError</strong> ‚Äì <ul>
<li><p>If the variable(s) contain null values.
    - If the dataframe not of the same size as that used in fit().</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X</strong> ‚Äì The dataframe with the transformed variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>pandas dataframe</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="ballet.eng.featuretools.html" class="btn btn-neutral float-right" title="ballet.eng.featuretools module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="ballet.eng.external.html" class="btn btn-neutral float-left" title="ballet.eng.external module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2018, Micah Smith.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>